<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     oyzy
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/YoungZiyi"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">oyzy</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-python中的生成器和迭代器" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/26/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"
    >python中的迭代器和生成器</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/26/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="article-date">
  <time datetime="2020-03-26T13:15:32.000Z" itemprop="datePublished">2020-03-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>复习一下python的高级特性</p>
<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>当需要迭代一个对象时, 会自动调用<code>iter</code>函数, <code>iter</code>函数会检查对象是否实现了<br><code>__iter__</code>方法, 如果有则调用对象的<code>__iter__</code>方法获取一个迭代器, 没有则继续检查对象<br>是否实现了<code>__getitem__</code>方法, 如果有, python会自动创建一个迭代器, 使用从0开始的索引<br>为参数调用<code>__getitem__</code>, 该方法将返回对应索引的元素, 如果<code>__getitem__</code>方法也不存<br>在, 则抛出<code>TypeError</code>异常, 提示对象不可迭代</p>
<p>可迭代对象(iterable)就是使用内置函数<code>iter</code>可以获取迭代器的对象, 该对象要么实现了能<br>够直接返回迭代器的<code>__iter__</code>方法, 要么实现了接受从0开始的索引为参数的<code>__getitem__</code><br>方法</p>
<p>由于<code>__iter__</code>方法需要返回迭代器, 先给出实现<code>__getitem__</code>方法的可迭代对象示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">it1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.text[index]</span><br><span class="line"></span><br><span class="line">obj = it1(<span class="string">'abcdefg'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="comment"># 依次打印 a, b, c, d, e, f, g</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>


<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器(iterator)就是实现了<code>__next__</code>方法的对象, 该方法也是返回序列的当前元素, 它跟<br><code>__getitem__</code>的区别就是, 当前元素的索引是保存在迭代器对象实例中, 而<code>__getitem__</code>是<br>由python解释器自动创建的迭代器提供的索引</p>
<p>迭代器实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">it2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            curr_char = self.text[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line"></span><br><span class="line">obj = it2(<span class="string">'abcdefg'</span>)</span><br><span class="line">print(next(i2))<span class="comment"># 输出 a</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 b</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 c</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 d</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 e</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 f</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 g</span></span><br></pre></td></tr></table></figure>

<p>我们使用<code>for</code>语句迭代一个对象(<code>obj</code>)过程如下:</p>
<ol>
<li>使用内置函数<code>iter</code>获取<code>obj</code>对象的迭代器 (分两种情况, 第一种是通过<code>__iter__</code>直接获取对象的迭代器,<br>第二种是通过python解释器自动创建迭代器, 并通过<code>obj</code>对象的<code>__getitem__</code>方法获取序列元素)</li>
<li>获得迭代器<code>iter</code>后, 循环调用<code>next(iter)</code>获取元素, 直到<code>__next__</code>方法抛出StopIteration结束循环</li>
</ol>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是迭代器的子集, 所以它也属于迭代器, 只是它的实现方式不一样, 生成器更简洁, 而且<br>它不需要像迭代器一样维护一个索引, 它是通过<code>yield</code>语句来实现的</p>
<p>生成器函数实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">it3</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> curr_char <span class="keyword">in</span> text:</span><br><span class="line">        <span class="keyword">yield</span> curr_char</span><br><span class="line"></span><br><span class="line">obj = it3(<span class="string">'abcdefg'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="comment"># 依次打印 a, b, c, d, e, f, g</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>代码在执行到<code>yield</code>时, 将返回其后的值, 然后并不像<code>return</code>语句一样退出, 而是挂起函数<br>的状态, 下次再从当前胃继续执行</p>
<p>生成器表达式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">li = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">print(li)<span class="comment"># 输出 [0, 1, 4, 9, 16]</span></span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">li = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line">print(li)<span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x7ff563aa6938&gt;</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 0</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 1</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 4</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 9</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 16</span></span><br><span class="line">print(next(li))<span class="comment"># 自动抛出StopIteration异常</span></span><br></pre></td></tr></table></figure>

<p>生成器除了实现简洁外, 它还有节省内存的优点, 它不是一次性构建整个结果列表, 它有延迟计<br>算的特点, 按需产生结果</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-hello-world" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/26/hello-world/"
    >Hello World</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/26/hello-world/" class="article-date">
  <time datetime="2020-03-26T02:00:08.204Z" itemprop="datePublished">2020-03-26</time>
</a>
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-PHP框架的路由实现浅析" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/10/24/PHP%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%9E%90/"
    >PHP框架的路由实现浅析</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/10/24/PHP%E6%A1%86%E6%9E%B6%E7%9A%84%E8%B7%AF%E7%94%B1%E5%AE%9E%E7%8E%B0%E6%B5%85%E6%9E%90/" class="article-date">
  <time datetime="2018-10-24T15:15:11.000Z" itemprop="datePublished">2018-10-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%A1%86%E6%9E%B6/">框架</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>todo</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BA%94%E7%94%A8%E6%8A%80%E6%9C%AF/" rel="tag">应用技术</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-select-poll-epoll-初探" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/05/11/select-poll-epoll-%E5%88%9D%E6%8E%A2/"
    >select poll epoll 初探</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/11/select-poll-epoll-%E5%88%9D%E6%8E%A2/" class="article-date">
  <time datetime="2018-05-11T03:11:11.000Z" itemprop="datePublished">2018-05-11</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/epoll/">epoll</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="select-poll-epoll-初探"><a href="#select-poll-epoll-初探" class="headerlink" title="select poll epoll 初探"></a>select poll epoll 初探</h1><p>这三个都是所谓的synchronous I/O multiplexing（同步I/O多路复用），在学习这个之前，有必要了解一下常见的I/O模型，<br>而在了解I/O模型前又又必要了解一下内核空间及用户空间。</p>
<h2 id="1-内核空间-用户空间"><a href="#1-内核空间-用户空间" class="headerlink" title="1 内核空间/用户空间"></a>1 内核空间/用户空间</h2><p>所谓的内核空间就是操作系统使用的内存空间，用户空间就是用户进程使用的内存空间，为了操作系统的安全，用户进程不能直接<br>操作操作系统内存空间，所以，内核空间和用户空间的数据交换需要通过内核提供的一组接口进行，也就是常说的系统调用。</p>
<h2 id="2-I-O模型"><a href="#2-I-O模型" class="headerlink" title="2 I/O模型"></a>2 I/O模型</h2><p>I/O模型就是I/O操作的方式，I/O操作就是用户进程与外界数据交换的操作，而与外界进行数据交换需要操作系统内核提供支持，<br>常见的I/O模型又四种，阻塞I/O、非阻塞I/O、多路复用I/O、信号驱动I/O、异步I/O。</p>
<h3 id="2-1-阻塞I-O（blocking-I-O）"><a href="#2-1-阻塞I-O（blocking-I-O）" class="headerlink" title="2.1 阻塞I/O（blocking I/O）"></a>2.1 阻塞I/O（blocking I/O）</h3><p>阻塞I/O就是进程请求I/O操作时会阻塞，具体一点就是用户进程向操作系统发起I/O请求，例如read操作中调用了系统函数recvfrom，<br>内核收到请求后就开始了I/O操作的第一个阶段————准备数据，如果是网络I/O请求，那么内核需要等待足够的数据到来，这时数据<br>保存在内核缓冲区，在这这个等待过程中，用户进程一直处于阻止塞状态（当然用户的I/O请求中也可以设置非阻塞，下面会提到），<br>当数据准备好了，内核就会将数据从内核缓冲区中拷贝到用户空间。用户感知到的就是调用recvfrom后，进程阻塞，直到数据准备<br>好了返回给用户进程。这就是最易理解的I/O模式。</p>
<h3 id="2-2-非阻塞I-O（nonblocking-I-O）"><a href="#2-2-非阻塞I-O（nonblocking-I-O）" class="headerlink" title="2.2 非阻塞I/O（nonblocking I/O）"></a>2.2 非阻塞I/O（nonblocking I/O）</h3><p>可以设置socket使之成为non-blocking，继续以读操作为例子，在非阻塞I/O模式中，当用户进程调用recvfrom时，内核立即返回，<br>在内核还未准备好数据时返回error，用户进程可以隔一段时间再次调用recvfrom，直到内核准备好数据，就会把数据考哦被到用户<br>空间，完成I/O操作。</p>
<h3 id="2-3-I-O多路复用"><a href="#2-3-I-O多路复用" class="headerlink" title="2.3 I/O多路复用"></a>2.3 I/O多路复用</h3><p>I/O多路复用类似非阻塞I/O，不一样的是使用多路复用机制可以使一个进程同时处理多个网络连接的I/O，基本原理是通过select<br>poll epoll会不断轮询多个socket，当其中某个I/O就绪就会通知用户进程。</p>
<h3 id="2-3-异步I-O（Asynchronous-I-O）"><a href="#2-3-异步I-O（Asynchronous-I-O）" class="headerlink" title="2.3 异步I/O（Asynchronous I/O）"></a>2.3 异步I/O（Asynchronous I/O）</h3><p>异步I/O是一种完全不会阻塞的I/O模型，之所以说完全不会阻塞是因为使用这种方式发起I/O请求后，内核立即返回，之后内核准备<br>数据，数据准备好后直接拷贝至用户空间，最后向用户进程发送一个signal，告诉进程I/O操作完成。而非阻塞I/O模型中，非阻塞<br>的是内核数据准备阶段，在数据拷贝阶段还是会阻塞用户进程。</p>
<h3 id="2-4-信号驱动I-O（Signal-drived-I-O）"><a href="#2-4-信号驱动I-O（Signal-drived-I-O）" class="headerlink" title="2.4 信号驱动I/O（Signal drived I/O）"></a>2.4 信号驱动I/O（Signal drived I/O）</h3><p>使用信号驱动I/O时，当网络套接字可读后，内核通过发送SIGIO信号通知应用进程，于是应用可以开始读取数据。有时也称此方式为<br>异步I/O。但是严格讲，该方式并不能算真正的异步I/O，因为实际读取数据到应用进程缓存的工作仍然是由应用自己负责的，即需要<br>用户主动调用系统函数去读取数据。</p>
<h2 id="3-I-O多路复用之select-poll-epoll"><a href="#3-I-O多路复用之select-poll-epoll" class="headerlink" title="3 I/O多路复用之select poll epoll"></a>3 I/O多路复用之select poll epoll</h2><p>select poll epoll都属于I/O多路复用模式的实现。</p>
<h3 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1 select"></a>3.1 select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param n: readfds writefds exceptfds中的fd数量不能超过n+1</span></span><br><span class="line"><span class="comment"> * @param readfds: 需要监控的读操作fd</span></span><br><span class="line"><span class="comment"> * @param writefds: 需要监控的写操作fd</span></span><br><span class="line"><span class="comment"> * @param exceptfds: 需要监控的异常fd</span></span><br><span class="line"><span class="comment"> * @param timeout: 指定select可以等待的时间间隔，如果设成0秒和0毫秒，则select不等待，立即测试fd集中的所有fd，</span></span><br><span class="line"><span class="comment"> *                 如果设成NULL，等待无限久，可以被信号中断</span></span><br><span class="line"><span class="comment"> * @return 成功:返回三个集合中所有被设置的bit位数量|超时:返回0|失败:返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>fd_set是以位图的形式来存储这些文件描述符，n为位图的长度。<br>select优点：<br>目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点<br>select缺点：<br>1.每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大，同时每次调用 select() 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大。<br>2.单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低   </p>
<h3 id="3-2-poll"><a href="#3-2-poll" class="headerlink" title="3.2 poll"></a>3.2 poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param fds: 需要监控的文吉安描述符及需要监控的事件</span></span><br><span class="line"><span class="comment"> * @param nfds: fds中的文件描述符总数</span></span><br><span class="line"><span class="comment"> * @param timeout: 和select一样但是两个字段单位分别是秒和微秒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 成功:返回正整数，返回又时间发生的fd数量|超时:返回0（也表示无事件发生）|失败:返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    short events;     <span class="comment">/* requested events */</span></span><br><span class="line">    short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>poll使用链表保存文件描述符，因此没有了监视文件数量的限制。</p>
<h3 id="3-3-epoll"><a href="#3-3-epoll" class="headerlink" title="3.3 epoll"></a>3.3 epoll</h3><p>epoll实现机制和select/poll完全不一样，设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？<br>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll的用法一句话描述就是三步曲：<br>第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。<br>第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。<br>第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。    </p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/epoll/" rel="tag">epoll</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-原码-反码-补码" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/12/19/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/"
    >原码、反码、补码学习</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/12/19/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/" class="article-date">
  <time datetime="2017-12-19T08:57:11.000Z" itemprop="datePublished">2017-12-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="原码、反码、补码学习"><a href="#原码、反码、补码学习" class="headerlink" title="原码、反码、补码学习"></a>原码、反码、补码学习</h1><p>思考：</p>
<blockquote>
<p>计算机中数的表示是怎样的？<br>计算机是如何做运算？  </p>
</blockquote>
<h2 id="计算机是二进制世界"><a href="#计算机是二进制世界" class="headerlink" title="计算机是二进制世界"></a>计算机是二进制世界</h2><p>众所周知，计算机世界里只有0和1，那么计算机中的数只能用二进制来表示，<br>举几个二进制数字例子：    </p>
<blockquote>
<p><em>括号中为二进制，其余为十进制</em><br>(0000 0001) = 1<br>(1111 1111) = 257   </p>
</blockquote>
<p>如何表示一个负数呢？很自然就能想到，使用一位用来表示符号，一般二进制数的第一位来表示符号，<br>0表示正数，1表示负数，例子：   </p>
<blockquote>
<p>(0000 0001) =&gt; 1<br>(1000 0001) =&gt; -1   </p>
</blockquote>
<p>这种表示方式就是所谓的<strong>原码</strong>，它很简单，容易被人脑所理解。不过使用它进行运算时，对计算机并不太友好，</p>
<h2 id="计算机数的运算"><a href="#计算机数的运算" class="headerlink" title="计算机数的运算"></a>计算机数的运算</h2><p>计算机是使用逻辑电路进行运算，下图就是简单的加法器：<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Full-adder_logic_diagram.svg/400px-Full-adder_logic_diagram.svg.png" alt="1-bit full adder"><br>图 一位简单全加器   </p>
<p>这个加法器有三个输入两个输出，一个加法器可以完成两位的加法运算，串联多个加法器可以做多位加法。<br>实现了加法器，但是如何做减法运算呢？难道还要实现一个减法器？答案是不需要，我们知道<code>a + b = a + (-b)</code>，<br>我们可以把减法转换成加法来计算，不过这个时候，使用原码就有问题了，不信我们试试看：      </p>
<blockquote>
<p>(84-81) = 84+(-81) = 3<br>  (0101 0100) 84的原码<br>  (1101 0001) -81的原码<br> ————————————<br> 1(0010 0101)          </p>
</blockquote>
<p>结果显然是错的，原码没办法使用加法器做加法运算，<strong>反码</strong>便出现了。   </p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>原码和反码可以互相转换，转换规则就是：  </p>
<blockquote>
<p>正数的反码和原码相同<br>负数的反码是原码除符号位外，其余位取反的结果  </p>
</blockquote>
<p>举个例子：      </p>
<blockquote>
<p>(15-125) = 15+(-125)<br>  (0000 1111) 15的原码   =&gt; (0000 1111) 15的反码<br>  (1111 1101) -125的原码 =&gt; (1000 0010) -125的反码<br>————————————————————<br>                            (1001 0001)   </p>
</blockquote>
<p>得出来的结果也是反码，转换成原码后是<code>(1110 1110)</code>，即为<code>-110</code>，结果正确！<br>不过，使用反码需要注意两点:  </p>
<blockquote>
<p>1.相加得到的结果也是反码，需要转换成原码<br>2.溢出一位后需要在最低位+1   </p>
</blockquote>
<p>使用补码，就没有问题了。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数的补码就是其本身，负数的补码就是其反码的最低位加1。   </p>
<blockquote>
<p>2-1 = 2+(-1) = 1<br>   (0000 0010) 2的原码   =&gt; (0000 0010) 2的反码   =&gt; (0000 0010) 补码<br>   (1000 0001) -1的原码  =&gt; (1111 1110) -1的反码  =&gt; (1111 1111) 补码<br>————————————————————————————————<br>  (0000 0001)    </p>
</blockquote>
<h2 id="隐藏其中的数学原理"><a href="#隐藏其中的数学原理" class="headerlink" title="隐藏其中的数学原理"></a>隐藏其中的数学原理</h2><p>todo</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-IP地址结构及子网划分" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/11/23/IP%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/"
    >IP地址结构及子网划分</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/11/23/IP%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/" class="article-date">
  <time datetime="2017-11-23T14:57:11.000Z" itemprop="datePublished">2017-11-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E7%BD%91%E7%BB%9C/">网络</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>todo</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-PEP-333——Python-Web服务器网关接口" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/08/24/PEP-333%E2%80%94%E2%80%94Python-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3/"
    >PEP333——Python Web服务器网关接口</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/08/24/PEP-333%E2%80%94%E2%80%94Python-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2017-08-24T14:32:11.000Z" itemprop="datePublished">2017-08-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/PEP/">PEP</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="PEP-333——Python-Web服务器网关接口-v1-0"><a href="#PEP-333——Python-Web服务器网关接口-v1-0" class="headerlink" title="PEP 333——Python Web服务器网关接口 v1.0"></a>PEP 333——Python Web服务器网关接口 v1.0</h1><p>Original: <a href="https://www.python.org/dev/peps/pep-0333/#abstract" target="_blank" rel="noopener">PEP 333——Python Web Server Gateway Interface v1.0</a>  </p>
<blockquote>
<p>PEP:    333<br>Title:    Python Web Server Gateway Interface v1.0<br>Author:    Phillip J. Eby <pje at telecommunity.com><br>Discussions-To:    Python Web-SIG <web-sig at python.org><br>Status:    Final<br>Type:    Informational<br>Created:    07-Dec-2003<br>Post-History:    07-Dec-2003, 08-Aug-2004, 20-Aug-2004, 27-Aug-2004, 27-Sep-2010<br>Superseded-By:    3333  </p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注意：此份规范的更新版本支持python3.x、包含社区勘误表、附录表，以及说明，如果这是你想要的，那么去看<a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener">PEP 3333</a>。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这篇文档介绍了在服务器和python web应用程序（或框架）之间建立一套标准接口，使python web应用程序可以在多种web服务器之间运行，提高可移植性。</p>
<h2 id="原理及目标"><a href="#原理及目标" class="headerlink" title="原理及目标"></a>原理及目标</h2><p>目前python拥有大量web应用框架，<br>例如Zope，Quixote，Webware，SkunkWeb，PSO，以及Twisted Web，<br>等等<a href="http://www.python.org/cgi-bin/moinmoin/WebProgramming" target="_blank" rel="noopener">1</a>，<br>数量众多的选择对新手来说是个头疼的问题，<br>因为，他们对web框架的选择将会限制所能使用的web服务器，反之亦然。  </p>
<p>相比之下，尽管java也有大量web应用框架，<br>但是java servlet API使得任何使用java框架写的应用程序都可以在任何支持java sevlet的web服务器上运行。</p>
<p>python也需要那样一套可用的广泛传播的API，<br>无论服务器是用python语言写的（Medusa），<br>或者把python封装进去（mod_python），<br>或者通过网关协议调用python解释器来执行程序（CGI,FastCGI,etc）都将使得对框架的选择脱离web服务器的限制，<br>让用户自由选择最适合他们的组合，<br>而且还能使框架和web服务器的开发者们专注于做好他们擅长的工作。</p>
<p>因此，这份PEP提议在web服务器和web应用程序或框架之间建立一套简单而通用的接口：<br>Python Web服务器网关接口（WSGI）。</p>
<p>但是仅仅起草一份WSGI规范并不能解决python web服务器和框架现有的状况，<br>服务器、框架作者和维护人员必须真正的实现WSGI才会有效果。</p>
<p>然而，由于还没有任何服务器或者框架支持WSGI，<br>最初实现对WSGI的支持对作者来说并没有立即产生效果。<br>因此，WSGI规范必须简洁，<br>至少能使作者实现接口的成本比较低。</p>
<p>因此，服务器和框架两端的接口实现起来都比较简单，这对WSGI接口的实用性都非常重要，<br>对任何设计决策来说都是基本原则。</p>
<p>注意，然而，框架实现对WSGI的支持并不像使用WSGI接口那般简单。<br>WSGI提供一个完全没有多余功能的接口给框架作者，<br>因为多余的类似响应对象和cookie的处理将会阻碍框架中已实现的相同功能。<br>再一次，WSGI的目标是使服务器和应用或框架之间交互更简单，而不是创造一个新的框架。</p>
<p>还要注意的是，这个目标阻止WSGI需要任何已部署python版本中不存在的东西。<br>因此，这份规范并不提议或者要求使用新标准库，<br>另外WSGI不需要任何高于python2.2.2版本的特性。<br>（对未来python版本中，最好是在标准库提供的web服务器中实现对接口的支持。）</p>
<p>另外，对现存以及未来的框架和服务器实现起来都应该简单，<br>它还要能够简单创建请求预处理器和响应后处理器（？），<br>其他基于WSGI的“中间件”对他们的服务器来说像一个应用，<br>对他们的应用来说却像一个服务器。</p>
<p>如果中间件能够既简单又强健，<br>而且WSGI被服务器和框架广泛支持，<br>那么它将允许一个全新的python web应用框架：<br>一个由低耦合WSGI中间件组件组成的框架。<br>甚至框架作者可能选择重构他们框架中的服务以提供上述架构，<br>使用WSGI更像使用一个库，<br>而不是一个庞大的框架。<br>这将使得应用开发者能够选择最佳组件以应对特殊的应用场景，<br>而不是不得不接受同一个框架中不好的一面。</p>
<p>当然，要实现上述愿景，<br>还有一条很长的路要走。<br>在此期间，有足够的短期目标使WSGI能够在任何框架和服务器上使用。</p>
<p>最后，需要提到的是，目前的WSGI版本并没有规定任何特殊的结构来使用web服务器或网关部署一个应用。<br>目前，这是由服务器或网关定义的。<br>当足够多的服务器和框架实现了WSGI，可以提供多种不同的部署需求，<br>那么需要创建另一份PEP，为WSGI服务器和应用框架描述一个部署标准。</p>
<h2 id="规范概览"><a href="#规范概览" class="headerlink" title="规范概览"></a>规范概览</h2><p>WSGI接口有两端：服务器或网关端，应用或框架端。<br>应用端提供一个可调用对象给服务器端调用。<br>如何提供这个可调用对象的细节则由服务器或网关决定。<br>假设一些服务器或网关会要求应用提供一个部署脚本，用来提供给服务器或网关创建一个实例，<br>来提供一个应用程序对象。<br>其他的服务器或网关可能使用配置文件或者其他结构来指定从哪里引入（或者说获得）应用程序对象。</p>
<p>另外为了使通信双方更加纯粹，<br>可以使用中间件来同时实现WSGI的两端。<br>那么他对服务器来说是一个应用，<br>对应用过来说则是扮演服务器的角色，<br>还能用来提供扩展APIs，内容转换，导航，以及其他有用的功能。</p>
<p>贯穿这篇规范说明，<br>我们会使用“可调用对象”来表示一个“函数”，“方法”，“类”或者一个有<strong>call</strong>方法的实例。<br>至于这个“可调用搞对象”具体是什么，这取决于服务器，网关，或者应用根据需要选择合适的技术来实现可调用对象。</p>
<h3 id="应用端-框架端"><a href="#应用端-框架端" class="headerlink" title="应用端/框架端"></a>应用端/框架端</h3><p>应用对象就是一个简单的接受两个参数的可调用对象，<br>术语“对象”并不是特指一个真正的对象实例：<br>一个函数，方法，类或者实现了<strong>call</strong>方法的实例都可以作为一个应用对象。<br>应用对象必须要能够调用多次，<br>几乎所有的服务器或网关（除了CGI）都会有重复的请求。</p>
<blockquote>
<p>（注意：<br>虽然我们称它为应用对象，<br>但是应用开发者不应该把WSGI当作一个web programming API！<br>应用开发者们还是应该继续使用现有的，高级框架服务来开发他们的应用。<br>WSGI是框架和服务器开发者们的工具，而且不打算直接支持应用开发者。）</p>
</blockquote>
<p>这里有两个应用对象的例子；一个是函数，另一个是类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""最简单的应用对象"""</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppClass</span>:</span></span><br><span class="line">    <span class="string">"""实现和上面例子同样功能的应用对象，但是使用类来实现</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    （注意：‘AppClass’是一个应用，通过调用它返回一个‘AppClass’的实例，</span></span><br><span class="line"><span class="string">    一个通过可迭代返回值的应用对象。）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果我们想使用‘AppClass’的实例作为应用对象，那就应该实现__call__</span></span><br><span class="line"><span class="string">    方法，那样就能用过调用实例来执行应用，而且需要创建一个实例供服务器</span></span><br><span class="line"><span class="string">    或网关使用。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        status = <span class="string">'200 OK'</span></span><br><span class="line">        response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">        self.start(status, response_headers)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Hello world!\n"</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器端-网关端"><a href="#服务器端-网关端" class="headerlink" title="服务器端/网关端"></a>服务器端/网关端</h3><p>HTTP客户端每次发送一个请求，服务器或网关都会调用应用对象一次，<br>为了好理解，这里有一个简单的CGI网关，<br>通过一个接受应用对象的函数实现。<br>注意这个简单的例子只能处理有限的错误状况，<br>因为一个未捕捉的异常默认将会通过sys.stderr输出，并且由服务器记录日志。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_cgi</span><span class="params">(application)</span>:</span></span><br><span class="line"></span><br><span class="line">    environ = dict(os.environ.items())</span><br><span class="line">    environ[<span class="string">'wsgi.input'</span>]        = sys.stdin</span><br><span class="line">    environ[<span class="string">'wsgi.errors'</span>]       = sys.stderr</span><br><span class="line">    environ[<span class="string">'wsgi.version'</span>]      = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    environ[<span class="string">'wsgi.multithread'</span>]  = <span class="literal">False</span></span><br><span class="line">    environ[<span class="string">'wsgi.multiprocess'</span>] = <span class="literal">True</span></span><br><span class="line">    environ[<span class="string">'wsgi.run_once'</span>]     = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> environ.get(<span class="string">'HTTPS'</span>, <span class="string">'off'</span>) <span class="keyword">in</span> (<span class="string">'on'</span>, <span class="string">'1'</span>):</span><br><span class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'https'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'http'</span></span><br><span class="line"></span><br><span class="line">    headers_set = []</span><br><span class="line">    headers_sent = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_set:</span><br><span class="line">             <span class="keyword">raise</span> AssertionError(<span class="string">"write() before start_response()"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">             <span class="comment"># Before the first output, send the stored headers</span></span><br><span class="line">             status, response_headers = headers_sent[:] = headers_set</span><br><span class="line">             sys.stdout.write(<span class="string">'Status: %s\r\n'</span> % status)</span><br><span class="line">             <span class="keyword">for</span> header <span class="keyword">in</span> response_headers:</span><br><span class="line">                 sys.stdout.write(<span class="string">'%s: %s\r\n'</span> % header)</span><br><span class="line">             sys.stdout.write(<span class="string">'\r\n'</span>)</span><br><span class="line"></span><br><span class="line">        sys.stdout.write(data)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> exc_info:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> headers_sent:</span><br><span class="line">                    <span class="comment"># Re-raise original exception if headers sent</span></span><br><span class="line">                    <span class="keyword">raise</span> exc_info[<span class="number">0</span>], exc_info[<span class="number">1</span>], exc_info[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                exc_info = <span class="literal">None</span>     <span class="comment"># avoid dangling circular ref</span></span><br><span class="line">        <span class="keyword">elif</span> headers_set:</span><br><span class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">"Headers already set!"</span>)</span><br><span class="line"></span><br><span class="line">        headers_set[:] = [status, response_headers]</span><br><span class="line">        <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">    result = application(environ, start_response)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">if</span> data:    <span class="comment"># don't send headers until body appears</span></span><br><span class="line">                write(data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">            write(<span class="string">''</span>)   <span class="comment"># send headers now if body was empty</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            result.close()</span><br></pre></td></tr></table></figure>

<h3 id="中间件：同时扮演两端角色的组件"><a href="#中间件：同时扮演两端角色的组件" class="headerlink" title="中间件：同时扮演两端角色的组件"></a>中间件：同时扮演两端角色的组件</h3><p>“中间件”面对应用的时候扮演服务器的角色，而面对服务器的时候扮演应用的角色，<br>它提供以下功能：</p>
<ul>
<li>在相应的重写环境之后，根据目标URL把请求路由到不同的应用对象。</li>
<li>允许多个应用或者框架并行的运行在同一个进程中。</li>
<li>通过转发请求以及网络响应来实现负载平衡和远程处理。</li>
<li>执行内容预处理，例如应用XSL样式表。</li>
</ul>
<p>总之，中间件的存在是使“服务器/网关”端和“应用/框架”端之间透明，不需要任何特殊支持使两端能够交互。<br>想把中间件合并到应用的用户只需提供中间件组件给服务器，<br>中间件就好像是一个应用，配置好中间件使之去调用应用，<br>中间件又好像是一个服务器，代替服务器去调用应用。<br>当然，中间件封装的“应用”可能是另一个中间件封装的另一个应用，<br>如此循环，创建了所谓的“中间件堆栈”。</p>
<p>在极大程度上，中间件必须符合WSGI规范服务端和应用端的限制和要求。<br>在某些例子，对中间件的约束比单纯对服务器或应用还要严格，<br>这些要点将在规范中注明。</p>
<p>下面是一个中间件例子（非正式），它的作用是把文本转换成pig Latin式的儿童黑话（…?），<br>代码保存在Joe Strout的piglatin.py文件中。<br>（注意：一个健壮的中间件可能会使用更粗鲁的方式检查内容类型，<br>以及内容的编码格式。<br>另外，这个例子忽略了一个单词可能跨越块边界。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> piglatin <span class="keyword">import</span> piglatin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LatinIter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""Transform iterated output to piglatin, if it's okay to do so</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note that the "okayness" can change until the application yields</span></span><br><span class="line"><span class="string">    its first non-empty string, so 'transform_ok' has to be a mutable</span></span><br><span class="line"><span class="string">    truth value.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, result, transform_ok)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            self.close = result.close</span><br><span class="line">        self._next = iter(result).next</span><br><span class="line">        self.transform_ok = transform_ok</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.transform_ok:</span><br><span class="line">            <span class="keyword">return</span> piglatin(self._next())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._next()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latinator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># by default, don't transform output</span></span><br><span class="line">    transform = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, application)</span>:</span></span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line"></span><br><span class="line">        transform_ok = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start_latin</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Reset ok flag, in case this is a repeat call</span></span><br><span class="line">            <span class="keyword">del</span> transform_ok[:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers:</span><br><span class="line">                <span class="keyword">if</span> name.lower() == <span class="string">'content-type'</span> <span class="keyword">and</span> value == <span class="string">'text/plain'</span>:</span><br><span class="line">                    transform_ok.append(<span class="literal">True</span>)</span><br><span class="line">                    <span class="comment"># Strip content-length if present, else it'll be wrong</span></span><br><span class="line">                    response_headers = [(name, value)</span><br><span class="line">                        <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers</span><br><span class="line">                            <span class="keyword">if</span> name.lower() != <span class="string">'content-length'</span></span><br><span class="line">                    ]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            write = start_response(status, response_headers, exc_info)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> transform_ok:</span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">write_latin</span><span class="params">(data)</span>:</span></span><br><span class="line">                    write(piglatin(data))</span><br><span class="line">                <span class="keyword">return</span> write_latin</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LatinIter(self.application(environ, start_latin), transform_ok)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run foo_app under a Latinator's control, using the example CGI gateway</span></span><br><span class="line"><span class="keyword">from</span> foo_app <span class="keyword">import</span> foo_app</span><br><span class="line">run_with_cgi(Latinator(foo_app))</span><br></pre></td></tr></table></figure>


<h2 id="规范详述"><a href="#规范详述" class="headerlink" title="规范详述"></a>规范详述</h2><p>一个应用对象必须接受两个位置参数。<br>为了好理解，<br>我们分别给这两个参数取名为environ和start_response，<br>但是这也不是必须的。<br>服务器或网关必须用这两个位置参数去调用一个应用（例如，通过调用<code>result = application(environ, start_response)</code>）</p>
<p>environ参数是一个字典对象，<br>包含类似CGI环境参数。<br>这个对象必须是一个python内置的字典对象（不是一个子类，自定义字典类或者其他模拟字典类），<br>而且应用能够随意修改字典的内容。<br>字典还必须包含必要的WSGI变量（下节将会介绍），<br>以及包含服务器端扩展变量，将根据下面描述的来命名。</p>
<p>start_response参数是一个可调用对象，它接受两个必选参数和一个可选参数。<br>为了更好的理解，<br>我们分别命名这些参数status，response_headers，和exc_info，<br>但是他们同样不是必须叫这个名，<br>应用必须调用start_response对象，并且使用位置参数（例如，start_response(status, response_headers)）.</p>
<p>status参数是一个表状态的字符串，类似“999 Message here”，<br>response_headers是一个包含http响应头的元祖。<br>可选的exc_info参数在下节start_reponse()可调用对象和错误处理中介绍。<br>它仅在当应用程序出错或者打算在浏览器上显示错误信息的时候使用。</p>
<p><code>start_response()</code>必须返回一个<code>write</code>（主体数据）可调用对象，它接受一个位置参数：<br>HTTP响应主体的一部分字符串。<br>（注意：<code>write()</code>可调用对象仅用于某些现有框架必须的输出APIs；<br>如果可以避免，新的应用或框架就不应该适用这个对象。<br>参阅Buffering and Stream章节获取更多信息。）</p>
<p>当服务器调用时，<br>应用对象必须返回一个可迭代对象，返回0或更多字符串。<br>这可以通过很多方式来实现，<br>例如返回字符串列表<br>或者通过一个生成器函数实现应用程序对象，<br>或者用一个可迭代类实例来实现应用程序对象。<br>无论它时怎么实现的，<br>应用程序对象必须返回一个可迭代对象，返回0或更多字符串。</p>
<p>服务器或网关必须以非缓存的方式返回生成的字符串到客户机，<br>在另一个请求前，完成每一个字符串的返回。<br>（换句话说，应用必须自己做好缓存,<br>参阅Buffering and Stream章节获取更多有关应用程序输出处理的信息。）</p>
<p>服务器或网关按二进制字节序列来处理来处理生成的字符串：<br>尤其是，它应该确保行尾结束符不能被修改。<br>应用对象响应的数据必须必须适合在客户端展现。<br>（服务器或网关可能应用HTTP传输编码。或者其他实现HTTP功能的传输方式，例如字节范围传输。参阅下面的Other HTTP Features章节获取更多信息。）</p>
<p>如果能够调用<code>len(iterable)</code>，<br>服务器必须能够信任结果的准确度。<br>如果可迭代对象是通过应用提供的<code>__len__()</code>方法返回的，<br>则必须返回一个准确的结果。<br>（参阅Handling the Content-Length Header章节获取更多信息。）</p>
<p>如果应用返回的可迭代对象有一个<code>close()</code>方法，<br>服务器或网关必须调用那个方法以完成当前请求，<br>无论请求是否已经正常完成，或者由于错误提前终止<br>（这是用来支持应用程序的资源发布）。<br>这个协议是补充PEP 325的生成器支持章节，<br>以及其他常见有<code>close()</code>方法的可迭代对象。</p>
<p>（注意：应用必须在可迭代开始生成主题字符串之前调用<code>start_response()</code>，使得服务器能够在主体内容之前发送headers。）<br>然而，这个调用可以通过可迭代对象的首次迭代来调用实现，<br>所以，服务器必须不假设应用首先调用<code>start_response()</code>，然后在开始迭代。）</p>
<p>最后，服务器和网关必须不直接使用应用返回的可迭代对象的其他属性。<br>除非它在服务器或网关中是一个特别的实例，有自有的特别属性，<br>例如wsgi.file_wrapper返回“file wrapper”<br>（参阅Optional Platform-Specific File Handling）。<br>通常情况下，只有这里指定的属性，<br>或者通过例如PEP 234中的迭代APIs。</p>
<h3 id="变量environ"><a href="#变量environ" class="headerlink" title="变量environ"></a>变量<code>environ</code></h3><p>environ字典需要包含CGI环境变量，<br>定义在Common Gateway Interface规范<a href="http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt" target="_blank" rel="noopener">2</a>中。<br>下面的变量必须提供，<br>除非他们的值是空字符串，<br>则可能可以省略，除了额外注明的变量。</p>
<blockquote>
<ul>
<li><p>REQUEST_METHOD<br>The HTTP request method, such as “GET” or “POST”. This cannot ever be an empty string, and so is always required.  </p>
</li>
<li><p>SCRIPT_NAME<br>The initial portion of the request URL’s “path” that corresponds to the application object, so that the application knows its virtual “location”. This may be an empty string, if the application corresponds to the “root” of the server.  </p>
</li>
<li><p>PATH_INFO<br>The remainder of the request URL’s “path”, designating the virtual “location” of the request’s target within the application. This may be an empty string, if the request URL targets the application root and does not have a trailing slash.  </p>
</li>
<li><p>QUERY_STRING<br>The portion of the request URL that follows the “?”, if any. May be empty or absent.  </p>
</li>
<li><p>CONTENT_TYPE<br>The contents of any Content-Type fields in the HTTP request. May be empty or absent.  </p>
</li>
<li><p>CONTENT_LENGTH<br>The contents of any Content-Length fields in the HTTP request. May be empty or absent.  </p>
</li>
<li><p>SERVER_NAME, SERVER_PORT<br>When combined with SCRIPT_NAME and PATH_INFO, these variables can be used to complete the URL. Note, however, that HTTP_HOST, if present, should be used in preference to SERVER_NAME for reconstructing the request URL. See the URL Reconstruction section below for more detail. SERVER_NAME and SERVER_PORT can never be empty strings, and so are always required.  </p>
</li>
<li><p>SERVER_PROTOCOL<br>The version of the protocol the client used to send the request. Typically this will be something like “HTTP/1.0” or “HTTP/1.1” and may be used by the application to determine how to treat any HTTP request headers. (This variable should probably be called REQUEST_PROTOCOL, since it denotes the protocol used in the request, and is not necessarily the protocol that will be used in the server’s response. However, for compatibility with CGI we have to keep the existing name.)  </p>
</li>
<li><p>HTTP_ Variables<br>Variables corresponding to the client-supplied HTTP request headers (i.e., variables whose names begin with “HTTP_”). The presence or absence of these variables should correspond with the presence or absence of the appropriate HTTP header in the request.  </p>
</li>
</ul>
</blockquote>
<p>A server or gateway should attempt to provide as many other CGI variables as are applicable. In addition, if SSL is in use, the server or gateway should also provide as many of the Apache SSL environment variables [5] as are applicable, such as HTTPS=on and SSL_PROTOCOL. Note, however, that an application that uses any CGI variables other than the ones listed above are necessarily non-portable to web servers that do not support the relevant extensions. (For example, web servers that do not publish files will not be able to provide a meaningful DOCUMENT_ROOT or PATH_TRANSLATED.)</p>
<p>A WSGI-compliant server or gateway should document what variables it provides, along with their definitions as appropriate. Applications should check for the presence of any variables they require, and have a fallback plan in the event such a variable is absent.</p>
<p>Note: missing variables (such as REMOTE_USER when no authentication has occurred) should be left out of the environ dictionary. Also note that CGI-defined variables must be strings, if they are present at all. It is a violation of this specification for a CGI variable’s value to be of any type other than str.</p>
<p>In addition to the CGI-defined variables, the environ dictionary may also contain arbitrary operating-system “environment variables”, and must contain the following WSGI-defined variables:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>wsgi.version</td>
<td>The tuple (1, 0), representing WSGI version 1.0.</td>
</tr>
<tr>
<td>wsgi.url_scheme</td>
<td>A string representing the “scheme” portion of the URL at which the application is being invoked. Normally, this will have the value “http” or “https”, as appropriate.</td>
</tr>
<tr>
<td>wsgi.input</td>
<td>An input stream (file-like object) from which the HTTP request body can be read. (The server or gateway may perform reads on-demand as requested by the application, or it may pre- read the client’s request body and buffer it in-memory or on disk, or use any other technique for providing such an input stream, according to its preference.)</td>
</tr>
<tr>
<td>wsgi.errors</td>
<td>An output stream (file-like object) to which error output can be written, for the purpose of recording program or other errors in a standardized and possibly centralized location. This should be a “text mode” stream; i.e., applications should use “\n” as a line ending, and assume that it will be converted to the correct line ending by the server/gateway.    <br><br>    For many servers, wsgi.errors will be the server’s main error log. Alternatively, this may be sys.stderr, or a log file of some sort. The server’s documentation should include an explanation of how to configure this or where to find the recorded output. A server or gateway may supply different error streams to different applications, if this is desired.</td>
</tr>
<tr>
<td>wsgi.multithread</td>
<td>This value should evaluate true if the application object may be simultaneously invoked by another thread in the same process, and should evaluate false otherwise.</td>
</tr>
<tr>
<td>wsgi.multiprocess</td>
<td>This value should evaluate true if an equivalent application object may be simultaneously invoked by another process, and should evaluate false otherwise.</td>
</tr>
<tr>
<td>wsgi.run_once</td>
<td>This value should evaluate true if the server or gateway expects (but does not guarantee!) that the application will only be invoked this one time during the life of its containing process. Normally, this will only be true for a gateway based on CGI (or something similar).</td>
</tr>
</tbody></table>
<p>Finally, the environ dictionary may also contain server-defined variables. These variables should be named using only lower-case letters, numbers, dots, and underscores, and should be prefixed with a name that is unique to the defining server or gateway. For example, mod_python might define variables with names like mod_python.some_variable.</p>
<h3 id="Input-and-Error-Streams"><a href="#Input-and-Error-Streams" class="headerlink" title="Input and Error Streams"></a>Input and Error Streams</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] The Python Wiki “Web Programming” topic (<a href="http://www.python.org/cgi-bin/moinmoin/WebProgramming" target="_blank" rel="noopener">http://www.python.org/cgi-bin/moinmoin/WebProgramming</a>)<br>[2] The Common Gateway Interface Specification, v 1.1, 3rd Draft (<a href="http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt" target="_blank" rel="noopener">http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt</a>)</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-散列" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/08/24/%E6%95%A3%E5%88%97/"
    >散列</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/08/24/%E6%95%A3%E5%88%97/" class="article-date">
  <time datetime="2017-08-24T14:32:11.000Z" itemprop="datePublished">2017-08-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>参考《数据结构与算法分析（C语言描述）》 第二版 第五章 散列</p>
<h1 id="什么是散列表？"><a href="#什么是散列表？" class="headerlink" title="什么是散列表？"></a>什么是散列表？</h1><p>散列表是一种数据结构，它支持对一组元素进行各种操作，不过它只支持二叉查找树所允许的一部分操作。<br>散列表的实现叫做散列，散列是一种可以用常数时间执行插入、删除和查找的技术，但是它对排序操作是不支持的。</p>
<h1 id="理想的散列表"><a href="#理想的散列表" class="headerlink" title="理想的散列表"></a>理想的散列表</h1><p>理想的散列表就是一个包含关键字的，具有固定大小的数组。每个关键字被映射到从 0 到 tableSize-1 这个范围中的某个数，<br>这个映射叫做散列函数，理想的情况下，任何两个不同的的关键字，映射到不同的单元。我们需要找一个散列函数，使能够在单元<br>间均匀的分配关键字。</p>
<h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>如果关键字是整数，那么直接返回 key % tableSize</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> tableSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % tableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而当关键字的取值具有一些不理想的性质时，上面这个散列函数就是一个不好的选择，例如，当tableSize = 10时，关键字都是<br>个位数为 0 的整数，那么上面这个散列函数返回的值永远是0，也就是说，所有的关键字都被映射到单元0了，这是不好的。为了使<br>分配的更均匀，tableSize最好为素数。<br>一般，关键字的的值都是字符串，那么有以下几种方法来实现散列函数</p>
<ul>
<li>第一种，把字符的ASCII码值加起来，然后再模tableSize。这样的缺点就是当tableSize很大时，分配就不会均匀。</li>
<li>第二种，假设关键字是由三个英文字母组成，那么三个字符有17576种组合（26的三次方），如果表大小是10007，<br>这就是一个合理的均匀分配，但是，英文并不是随机组合，三个字幕组成有效的单词大概只有2851个，即使没有冲突，<br>也只有表的28%被散列到，所以也是不合适的。</li>
<li>第三种涉及到字符串中所有字符，所以当关键字特别长时，计算会花费过多时间，解决方法就是不计算所有字符，而挑选其中的字符，<br>比如只计算奇数位上的字符。</li>
</ul>
<h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><p>当两个关键字计算后得出的散列值相同时，就会产生冲突，解决冲突有两种方法：分离链接法 &amp; 开放定址法</p>
<h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>该方法将所有散列值相同的元素保留到一个表中，这种方法的缺点就是使用了指针，由于给新单元分配指针需要时间，因此导致算法速度<br>较慢，另外，它还依赖另一种数据结构（链表）。</p>
<h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>开放定址法中如果遇到了冲突，则尝试选择另外的单元，直到找到空的单元为止。</p>
<h2 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h2><p>使用前面两种方法解决冲突时，当表的元素过多时，操作的运行时间将过长，而且insert操作可能失败。解决方案就是扩展表，使表增大<br>一倍，并使用一个新的散列函数，扫描原表中的元素，重新计算散列值并插入到新表中，这个操作就叫再散列。</p>
<h2 id="可扩散列"><a href="#可扩散列" class="headerlink" title="可扩散列"></a>可扩散列</h2><p>fuck，看不懂！</p>
<h1 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h1><ul>
<li>编译器中使用散列表跟踪源代码声明的变量，这种数据结构叫做<code>符号表</code>。</li>
<li>使用散列表解决图论问题。</li>
<li>游戏编程中</li>
<li>在线拼写检测程序</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>散列表以常数时间实现insert和find操作，但是当表中元素过多时，表的性能将下降。另外，当关键字的类型以及性质比较特殊时，选择<br>合适的散列散列函数也会很大程度上影响表的性能。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-python多线程编程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/08/05/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"
    >python多线程编程</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/08/05/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2017-08-05T03:11:11.000Z" itemprop="datePublished">2017-08-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="python多线程编程"><a href="#python多线程编程" class="headerlink" title="python多线程编程"></a>python多线程编程</h1><ol>
<li>为啥使用多线程？</li>
</ol>
<ul>
<li>有时候计算机要处理的任务之间没有因果关系，都是独立的，也就是说任务的结果不会影响其他任务，我们就会希望计算机并行的处理多个任务，这就要使用多线程。当然还有其他方式来实现多任务并行处理，比如说串行程序使用一个或多个计时器来实现一个多路复用的方案，一个串行程序需要从每个I/O终端通道来检查用户的输入，然而程序在读取I/O时不能阻塞，因为用户的输入是不确定时间的，阻塞会影响其他I/O通道的处理，串行程序必须使用非阻塞I/O或拥有计时器的阻塞I/O。由于串行程序只有一个执行线程，为了防止执行其中某一个任务占用太多时间，并对用户的响应进行合理分配，实现起来会有非常复杂的控制流，难以维护。</li>
</ul>
<ol start="2">
<li>进程和线程到底是啥？</li>
</ol>
<ul>
<li>进程（重量级进程）是一个执行中的程序，每个进程都有自己的地址空间、内存、数据栈、以及其他一些用于跟踪执行的辅助数据，操作系统管理其上所有进程的执行，为这些进程分配时间。进程可以通过派生（fork或spawn）新的进程来执行其他任务，由于每个进程都有自己的地址空间和内存。所以进程间只能通过进程间通信的方式共享信息。线程（轻量级进程）与进程类似，但是它们是在一个进程空间下面执行的，并共享上下文，可以将它们认为是在一个主进程中并行运行的一些迷你进程。</li>
</ul>
<ol start="3">
<li>python和线程和全局解释器锁</li>
</ol>
<ul>
<li>python代码是由python虚拟机执行的，python虚拟机其实就是模拟cpu核心，所以，同一时刻只能由一个线程在执行，多线程执行实质上是虚拟机不停的切换执行中的线程，为了保证同一时刻只有一个线程在执行，这里就用到全局解释器锁，所以对虚拟机的访问是由全局解释器锁来控制的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 设置GIL（Global Interpreter Lock）</span><br><span class="line">2. 切换一个线程去执行</span><br><span class="line">3. 执行</span><br><span class="line">    a. 指定数量的字节码指令</span><br><span class="line">    b. 线程主动让出控制权</span><br><span class="line">4. 切换出线程</span><br><span class="line">5. 解锁GIL</span><br><span class="line">6. 重复上述步骤</span><br></pre></td></tr></table></figure>
当调用外部代码（例如C/C++拓展内置函数），GIL会保持锁定，因为这期间没有python字节码计数，但是可以靠在拓展代码中手动解锁GIL。</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-python源码解析-读书笔记II" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/07/27/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0II/"
    >python源码解析 读书笔记II</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/07/27/python%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0II/" class="article-date">
  <time datetime="2017-07-27T14:03:11.000Z" itemprop="datePublished">2017-07-27</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/python/">python</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="python源码解析-读书笔记II-——-python虚拟机"><a href="#python源码解析-读书笔记II-——-python虚拟机" class="headerlink" title="python源码解析 读书笔记II —— python虚拟机"></a>python源码解析 读书笔记II —— python虚拟机</h1><h2 id="python执行过程"><a href="#python执行过程" class="headerlink" title="python执行过程"></a>python执行过程</h2><p>python源代码 输入 -&gt; python解释器 编译 -&gt; python字节码 输入 -&gt; python虚拟机 执行</p>
<h2 id="python编译编出来的到底是什么玩意？"><a href="#python编译编出来的到底是什么玩意？" class="headerlink" title="python编译编出来的到底是什么玩意？"></a>python编译编出来的到底是什么玩意？</h2><p>python是一门解释型语言，它编译后得到的不是机器码，而是叫字节码，就是以<code>.pyc</code>为后缀的文件。</p>
<p>python源代码中的静态信息（字符串、常量值）储存在一个运行时的对象中，这个对象就是<code>PyCodeObject</code>，python编译的结果其实就是这个对象，而<code>.pyc</code>文件就是这个对象在硬盘上的表现形式。</p>
<p>PyCodeObject对象的声明<br>code.h</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  PyObject_HEAD</span><br><span class="line">  <span class="keyword">int</span> co_argcount; <span class="comment">// Code block中位置参数的个数（位置参数？）</span></span><br><span class="line">  <span class="keyword">int</span> co_nlocals; <span class="comment">// Code block中局部变量的个数（包括位置参数）</span></span><br><span class="line">  <span class="keyword">int</span> co_stacksize; <span class="comment">// 执行这个code block需要的栈空间</span></span><br><span class="line">  <span class="keyword">int</span> co_flags;</span><br><span class="line">  PyObject *co_code; <span class="comment">// code block编译所得字节码的指令序列，以PyStringObject的形式存在</span></span><br><span class="line">  PyObject *co_consts; <span class="comment">// 保存该code block中所有常量，以PyTupleObject的形式存在</span></span><br><span class="line">  PyObject *co_names; <span class="comment">// 保存该code block中所有符号（？），以PyTupleObject的形式存在</span></span><br><span class="line">  PyObject *co_varnames；<span class="comment">// 保存该code block中左右局部变量名</span></span><br><span class="line">  PyObject *co_freevars; <span class="comment">// Python实现闭包需要用到的东西</span></span><br><span class="line">  PyObject *co_cellvars; <span class="comment">// code block中内部嵌套函数所引用的局部变量名集合</span></span><br><span class="line">  <span class="comment">/* THe rest doesn't count for hash/cmp */</span></span><br><span class="line">  PyObject *co_filename; <span class="comment">// code block中对应的py文件完整路径</span></span><br><span class="line">  PyObject *co_name; <span class="comment">// code block的名字，通常是函数名或类名</span></span><br><span class="line">  <span class="keyword">int</span> co_firstlineno; <span class="comment">// code block对应py文件中的起始行</span></span><br><span class="line">  PyObject *co_lnotab; <span class="comment">// 字节码指令与py文件中source code行号的对应关系，以PyStringObject的形式存在</span></span><br><span class="line">&#125; PyCodeObject;</span><br></pre></td></tr></table></figure>

<p>python代码中每一个code block都会创建一个PyCodeObject对象与之对应。code block就是一个 作用域/命名空间，例如一个 函数/类/源文件。</p>
<p>怎样生成<code>.pyc</code>文件</p>
<ul>
<li>import一个模块时，会生成该模块的pyc文件</li>
<li>python标准库中的py_compile、compiler工具</li>
</ul>
<p>import一个模块时，python会在设定好的path中按顺序查找以这个模块名命名的dll和pyc文件，如果只找到.py文件，那就会把源代码编译成PyCodeObject对象，并创建.pyc文件，把对象写入文件中，接下来python才会对.pyc文件进行加载操作。实际上就是把pyc文件的Code对象在内存上重新复制出来。</p>
<p>co_lnotab域储存的是字节码指令与py文件中source code行号的对应关系，而在python2.3以前，有一条字节码指令，叫SET_LINENO，这条字节码会记录py文件中source code的位置，python2.3之后编译不会再产生这条字节码，因为字节码代表的是运行时的行为，而记录源代码行号的动作完全可以在编译时完成，所以python会在编译时直接将这个信息记录到co_lnotab中。</p>
<p>python中可以访问PyCodeObject对象。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">source = open(<span class="string">'demo.py'</span>).read()</span><br><span class="line">co = compile(source, <span class="string">'demo.py'</span>, <span class="string">'exec'</span>) <span class="comment"># co就是PyCodeObject</span></span><br><span class="line">type(co) <span class="comment"># &lt;type 'code'&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="pyc文件的生成"><a href="#pyc文件的生成" class="headerlink" title="pyc文件的生成"></a>pyc文件的生成</h2><p>python的import机制会产生pyc文件，那么import时到底做了哪些操作？<br>import.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">write_compiled_module</span><span class="params">(PyCodeObject *co, <span class="keyword">char</span> *cpathname, <span class="keyword">long</span> mtime)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  FILE *fp;</span><br><span class="line">  fp = open_exclusive(cpathname); <span class="comment">// 排他性打开文件</span></span><br><span class="line">  <span class="comment">// 【1】写入Python magic number</span></span><br><span class="line">  PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION);</span><br><span class="line">  <span class="comment">// 【2】写入时间信息</span></span><br><span class="line">  PyMarshal_WriteLongToFile(mtime, fp, Py_MARSHAL_VERSION);</span><br><span class="line">  <span class="comment">// 【3】写入PyCodeObject对象</span></span><br><span class="line">  PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);</span><br><span class="line">  </span><br><span class="line">  fflush(fp);</span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>magic number是啥？<br>他是python定义的一个整数值，一般不同的版本的magic number不同，，这个值用来保证python的兼容性的。python加载pyc文件时首先会检查这个值，如果不同则会拒绝加载这个pyc文件。<br>另外这个值定义在import.c中。</p>
<p>为什么要写如时间信息？<br>这主要是为了保证pyc文件与源文件同步，当用户修改了源文件，python加载了较旧的pyc文件后，会检查发现pyc的时间早于py文件，于是会自动重新编译源文件，生成新的pyc文件。</p>
<p>PyCodeObject怎么写入文件中？<br>根据对象中不同类型的域调用不同的方法去写文件，在写对象之前都会先写入对象的类型，这样对pyc文件再次加载有重要作用。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/" rel="tag">读书笔记</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Ouyang Ziyi
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.jpg" alt="oyzy"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>