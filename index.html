<!DOCTYPE html>


<html lang="en" >


<head>
  <meta charset="utf-8" />
    
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <title>
     oyzy
  </title>
  <meta name="generator" content="hexo-theme-yilia-plus">
  
  <link rel="shortcut icon" href="/favicon.ico" />
  
  
<link rel="stylesheet" href="/dist/main.css">

  
  <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
  
  

  

</head>

</html>

<body>
  <div id="app">
    <main class="content on">
      
<section class="cover">
    
      
      <a class="forkMe" href="https://github.com/YoungZiyi"
        target="_blank"><img width="149" height="149" src="/images/forkme.png"
          class="attachment-full size-full" alt="Fork me on GitHub" data-recalc-dims="1"></a>
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover1.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">oyzy</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>

<div id="main">
  <section class="outer">
  <article class="articles">
    
    
    
    
    <article id="post-python异步IO" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/06/python%E5%BC%82%E6%AD%A5IO/"
    >python异步IO</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/06/python%E5%BC%82%E6%AD%A5IO/" class="article-date">
  <time datetime="2020-04-06T06:49:01.000Z" itemprop="datePublished">2020-04-06</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>cpu的速度远远快于磁盘IO以及网络IO等, 在同步IO模型下, 一旦遇到IO操作就需要等待IO完成, 在等待过程中, 当前线程被挂起, cpu无法继续执行后面的代码, 使用多线程/进程可以并发执行代码, 当一个线程被挂起, cpu就会执行其他线程, 实现并发执行</p>
<p>系统切换线程/进程的开销是非常大的, 一旦线程/进程数量过多, 切换所花的时间就越多, </p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-python编码问题" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/04/02/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/"
    >python编码问题</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/04/02/python%E7%BC%96%E7%A0%81%E9%97%AE%E9%A2%98/" class="article-date">
  <time datetime="2020-04-02T06:49:01.000Z" itemprop="datePublished">2020-04-02</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p><a href="https://nedbatchelder.com/text/unipain.html" target="_blank" rel="noopener">参考</a></p>
<h2 id="编码基础"><a href="#编码基础" class="headerlink" title="编码基础"></a>编码基础</h2><p><img src="/img/USASCII_code_chart.png" alt="ascii" title="source: upload.wikimedia.org"></p>
<p>这是ascii编码表, 从0到127, 每一个数字(code point)对应一个字符, 编码表就是这种对应<br>关系的映射表, 由于计算机只能处理字节, 所以还需要将数字保存为字节, <strong><em>ASCII编码</em></strong><br>规定使用一个字节</p>
<p>一个字节提供的编码位是从0到255, 足以存下ascii编码表中所有字符, 为了支持更多语言, 人<br>们使用更多的字节来定义一个字符, 例如使用两个字节的<code>gb2312</code>, <code>big5</code>,  他们分别用来处<br>理中文简体和中文繁体</p>
<p>不同的语言使用不同的编码表导致大量不同的编码表出现, 于是人们就想能不能一套编码表包含<br>所有语言, 于是<code>unicode</code>就出现了, <code>unicode</code>总共有1100000个编码位(code point), 目前<br>用到了110000个, 每种语言中的每一个字符在<code>unicode</code>中都使用一个编码位, 有了编码位与字<br>符之间的映射关系后, 还需要将编码位转成字节提供给计算机处理, <code>ASCII</code>编码就是简单的使<br>用一个字节来保存编码位, <code>unicode</code>标准定义了多种编码方式(encoding)来将编码位转成字<br>节, 例如<code>UTF-8</code>, <code>UTF-16</code>, <code>UTF-32</code>, <code>UCS-2</code>, <code>UCS-4</code>等等, <code>UTF-8</code>是我们常用的编<br>码, 它使用变长字节数来表示一个<code>unicode</code>编码位, <code>ASCII</code>中的字符在<code>UTF-8</code>中也是使用一<br>个字节, 且相同, 所以<code>ASCII</code>是<code>UTF-8</code>的子集</p>
<h2 id="python2中的编码"><a href="#python2中的编码" class="headerlink" title="python2中的编码"></a>python2中的编码</h2><p>python2中有两种字符串类型, 一种是<code>str</code>类型, 它储存的是字节, 另一种是<code>unicode</code>, 它储<br>存的是编码位, 如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'hi 你好'</span></span><br><span class="line">print(type(s1))<span class="comment"># &lt;type 'str'&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># use a 'u' prefix</span></span><br><span class="line">s2 = <span class="string">u'hi 你好'</span></span><br><span class="line">print(type(s2))<span class="comment"># &lt;type 'unicode'&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>str</code>类型的字符串保存的是字节, 所以使用<code>len</code>函数计算长度返回的将是字节数, 而<code>unicode</code><br>类型的字符串保存的是编码位, 将返回编码位个数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(len(s1))<span class="comment"># 9</span></span><br><span class="line"></span><br><span class="line">print(len(s2))<span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p><code>str</code>和<code>unicode</code>的字符串可以互相转换, <code>unicode</code>字符串可以通过<code>encode</code>方法转变成储存<br>字节的<code>str</code>类型, <code>str</code>字符串可以通过<code>decode</code>转变成<code>unicode</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(s1.decode(<span class="string">'utf-8'</span>))<span class="comment"># hi 你好</span></span><br><span class="line"></span><br><span class="line">print(s2.encode(<span class="string">'utf-8'</span>))<span class="comment"># hi 你好</span></span><br></pre></td></tr></table></figure>

<p><code>s1</code>是<code>str</code>类型, 保存的是计算机使用的字节码(Bytes), 它使用<code>decode</code>方法根据<code>UTF-8</code><br>编码表可以解码成<code>unicode</code>, <code>s2</code>是<code>unicode</code>类型, 它可以使用<code>encode</code>方法, 同样根据<br><code>UTF-8</code>编码表可以转变成字节码(Bytes), 如果使用错误的编码类型, 将返回编码错误</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">print(s1.decode(<span class="string">'ascii'</span>))</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 3: ordinal not in range(128)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释: s1 中的中文字符编码超出了ascii所能表示的范围, 所以解码失败</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不提供编码参数的话将使用默认编码</span></span><br><span class="line"><span class="comment"># 查看环境默认编码: sys.getdefaultencoding(), 我这里是 ascii</span></span><br><span class="line">print(s2.encode())</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># UnicodeEncodeError: 'ascii' codec can't encode characters in position 3-4: ordinal not in range(128)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释: s2中的中文编码位超过了ascii所能表示的范围, 所以编码失败</span></span><br><span class="line"></span><br><span class="line">print(s1.decode(<span class="string">'ascii'</span>, <span class="string">'replace'</span>))<span class="comment"># hi ������</span></span><br><span class="line">print(s2.encode(<span class="string">'ascii'</span>, <span class="string">'replace'</span>))<span class="comment"># hi ??</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释: 第二个参数使用replace将会使用'?'代替不可编码/解码的字符</span></span><br><span class="line"><span class="comment"># decode时返回了6个问号, 而encode只有两个, 这是因为s1字符串内部储存的是字节, 而中文</span></span><br><span class="line"><span class="comment"># '哈哈'使用了六个Bytes, 使用ascii解码时将六个字节当成六个字符处理, 因为超过了ascii</span></span><br><span class="line"><span class="comment"># 所能表示的范围, 所以返回六个问号, 而s2储存的时编码位, 其内部的中文'哈哈'是两个</span></span><br><span class="line"><span class="comment"># unicode编码位, 使用ascii编码时是当作两个字符处理, 超过了ascii表示范围, 返回两个问</span></span><br><span class="line"><span class="comment"># 号</span></span><br></pre></td></tr></table></figure>

<p>python2中很多地方都会存在隐性转换, 比如尝试将<code>unicode</code>字符串和<code>str</code>类型(字节)拼接起<br>来, python2先会自动将<code>str</code>字节字符串decode成默认编码类型的字符串, 然后再拼接</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">u'hi'</span> + <span class="string">' nihao'</span>)<span class="comment"># hi nihao</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">u'hi'</span> + <span class="string">' 你好'</span>)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment"># UnicodeDecodeError: 'ascii' codec can't decode byte 0xe4 in position 1: ordinal not in range(128)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解释: python2首先会将' 你好'按默认编码ASCII解码, 但是中文是超出了ASCII表示的范围,</span></span><br><span class="line"><span class="comment"># 所以报UnicodeDecodeError</span></span><br></pre></td></tr></table></figure>

<p>python2中隐性的字符串类型转换在所有字符都是ascii时表现正常, 当存在其他编码字符时就<br>可能导致错误</p>
<h2 id="python3中的编码"><a href="#python3中的编码" class="headerlink" title="python3中的编码"></a>python3中的编码</h2><p>python3中也有两种类型的字符串, 直接由引号括起来的字符串是<code>str</code>类型, 普通字符串加<code>b</code><br>前缀的字符串属于<code>bytes</code>类型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s1 = <span class="string">'hi 你好'</span></span><br><span class="line">print(type(s1))<span class="comment"># &lt;class 'str'&gt;</span></span><br><span class="line"></span><br><span class="line">s2 = <span class="string">b'hi how old are you'</span></span><br><span class="line">print(type(s2))<span class="comment"># &lt;class 'bytes'&gt;</span></span><br></pre></td></tr></table></figure>

<p>python2中的<code>str</code> 等价于 python3中的<code>bytes</code><br>python2中的<code>unicode</code> 等价于 python3中的<code>str</code></p>
<p>python3中不会做任何隐性的类型转换, 如果拼接<code>str</code>和<code>bytes</code>类型的字符串, 将会抛出<br><code>TypeError</code>错误</p>
<h2 id="编码问题最佳实现"><a href="#编码问题最佳实现" class="headerlink" title="编码问题最佳实现"></a>编码问题最佳实现</h2><p>编码问题并不复杂, 只要遵循以下几点就可以避免大部分的编码问题, python2/3同样适用</p>
<blockquote>
<p>1.bytes on the outside, Unicode on the inside.</p>
</blockquote>
<p>进出你的程序的数据必须是<code>bytes</code>类型, 在程序内部处理<code>unicode</code>字符串</p>
<blockquote>
<p>2.know what you have</p>
</blockquote>
<p>必须知道自己处理的数据是什么类型的字符串, 要确定到底是<code>bytes</code>还是<code>unicdoe</code>类型,<br>如果是<code>bytes</code>类型, 还需要知道它的编码是什么, 才可以根据对应的编码将<code>bytes</code>转换<br>为<code>unicode</code>, 但是, 数据的编码是无法仅仅根据<code>bytes</code>类型的字符串本身得出来, 要么<br>从数据源处得知, 要么只能靠猜</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><blockquote>
<p>1.编码表保存编码位与字符之间映射关系, <code>unicode</code>支持所有的语言字符, 它兼容<br><code>ascii</code></p>
<p>2.编码位(code points)是数字, 需要转换成字节才能让计算机处理, 转换规则由编<br>码方式决定, 例如<code>ASCII</code>编码使用一个字节保存它所支持的127个字符, <code>UTF-8</code>使<br>用可变长字节数保存<code>unicode</code>字符, 其中, <code>ASCII</code>中的字符在<code>UTF-8</code>中是完全一<br>样的, 所以<code>ASCII</code>是<code>UTF-8</code>的子集</p>
<p>3.python2有两种类型的字符串, <code>str</code>和<code>unicode</code>,<br><code>str</code>保存的是<code>bytes</code>,<br><code>unicode</code>保存的是<code>unicode</code>,<br><code>str</code>通过<code>decode</code>方法可以转换成<code>unicode</code>,<br><code>unicdoe</code>通过<code>encode</code>方法可以转换成<code>bytes</code>,</p>
<p>4.python3同样有两种类型的字符串, <code>str</code>和<code>bytes</code>,<br><code>str</code>保存的是<code>unicode</code>,<br><code>bytes</code>保存的是<code>bytes</code>,<br><code>str</code>通过<code>encode</code>方法转换成<code>bytes</code><br><code>bytes</code>通过<code>decode</code>方法转换成<code>str</code></p>
<p>5.python2中存在隐性转换字符串类型的现象, 例如拼接不同类型的字符串, 则会根据<br>默认编码自动将<code>bytes</code>转换成<code>unicode</code>再拼接, python3中拼接不同类型字符串则会<br>报错, tip1: 不要依赖自动转换, 任何时候都需要清楚的知道自己处理的字符串类型</p>
<p>6.程序内部处理的字符串都应该是<code>unicode</code>类型, 出去的都应该是<code>bytes</code>类型</p>
</blockquote>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-python中的生成器和迭代器" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/26/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/"
    >python中的迭代器和生成器</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/26/python%E4%B8%AD%E7%9A%84%E7%94%9F%E6%88%90%E5%99%A8%E5%92%8C%E8%BF%AD%E4%BB%A3%E5%99%A8/" class="article-date">
  <time datetime="2020-03-26T13:15:32.000Z" itemprop="datePublished">2020-03-26</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>复习一下python的高级特性</p>
<h2 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h2><p>当需要迭代一个对象时, 会自动调用<code>iter</code>函数, <code>iter</code>函数会检查对象是否实现了<br><code>__iter__</code>方法, 如果有则调用对象的<code>__iter__</code>方法获取一个迭代器, 没有则继续检查对象<br>是否实现了<code>__getitem__</code>方法, 如果有, python会自动创建一个迭代器, 使用从0开始的索引<br>为参数调用<code>__getitem__</code>, 该方法将返回对应索引的元素, 如果<code>__getitem__</code>方法也不存<br>在, 则抛出<code>TypeError</code>异常, 提示对象不可迭代</p>
<p>可迭代对象(iterable)就是使用内置函数<code>iter</code>可以获取迭代器的对象, 该对象要么实现了能<br>够直接返回迭代器的<code>__iter__</code>方法, 要么实现了接受从0开始的索引为参数的<code>__getitem__</code><br>方法</p>
<p>由于<code>__iter__</code>方法需要返回迭代器, 先给出实现<code>__getitem__</code>方法的可迭代对象示例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">it1</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span><span class="params">(self, index)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.text[index]</span><br><span class="line"></span><br><span class="line">obj = it1(<span class="string">'abcdefg'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="comment"># 依次打印 a, b, c, d, e, f, g</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>


<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器(iterator)就是实现了<code>__next__</code>方法的对象, 该方法也是返回序列的当前元素, 它跟<br><code>__getitem__</code>的区别就是, 当前元素的索引是保存在迭代器对象实例中, 而<code>__getitem__</code>是<br>由python解释器自动创建的迭代器提供的索引</p>
<p>迭代器实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">it2</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, text)</span>:</span></span><br><span class="line">        self.text = text</span><br><span class="line">        self.index = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            curr_char = self.text[self.index]</span><br><span class="line">        <span class="keyword">except</span> IndexError:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration()</span><br><span class="line"></span><br><span class="line">obj = it2(<span class="string">'abcdefg'</span>)</span><br><span class="line">print(next(i2))<span class="comment"># 输出 a</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 b</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 c</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 d</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 e</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 f</span></span><br><span class="line">print(next(i2))<span class="comment"># 输出 g</span></span><br></pre></td></tr></table></figure>


<h2 id="使用for迭代的过程"><a href="#使用for迭代的过程" class="headerlink" title="使用for迭代的过程"></a>使用for迭代的过程</h2><p>我们使用<code>for</code>语句迭代一个对象(<code>obj</code>)过程如下:</p>
<ol>
<li>使用内置函数<code>iter</code>获取<code>obj</code>对象的迭代器 (分两种情况, 第一种是通过<code>__iter__</code>直接<br>获取对象的迭代器, 第二种是通过python解释器自动创建迭代器</li>
<li>获得迭代器后, 循环调用<code>next(iter)</code>获取元素, <code>next</code>函数调用迭代器内部的<code>__next__</code><br>方法以获得序列中的元素, 直到<code>__next__</code>方法抛出StopIteration结束循环</li>
</ol>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>生成器是迭代器的子集, 所以它也属于迭代器, 只是它的实现方式不一样, 生成器更简洁, 而且<br>它不需要像迭代器一样维护一个索引, 它是通过<code>yield</code>语句来实现的</p>
<p>生成器函数实例</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">it3</span><span class="params">(text)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> curr_char <span class="keyword">in</span> text:</span><br><span class="line">        <span class="keyword">yield</span> curr_char</span><br><span class="line"></span><br><span class="line">obj = it3(<span class="string">'abcdefg'</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> obj:</span><br><span class="line">    <span class="comment"># 依次打印 a, b, c, d, e, f, g</span></span><br><span class="line">    print(i)</span><br></pre></td></tr></table></figure>

<p>代码在执行到<code>yield</code>时, 将返回其后的值, 然后并不像<code>return</code>语句一样退出, 而是挂起函数<br>的状态, 下次再从当前胃继续执行</p>
<h2 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h2><p>类似列表推导式, 只是方括号替换成大括号</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表推导式</span></span><br><span class="line">li = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>)]</span><br><span class="line">print(li)<span class="comment"># 输出 [0, 1, 4, 9, 16]</span></span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line">li = (x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">5</span>))</span><br><span class="line">print(li)<span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x7ff563aa6938&gt;</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 0</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 1</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 4</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 9</span></span><br><span class="line">print(next(li))<span class="comment"># 输出 16</span></span><br><span class="line">print(next(li))<span class="comment"># 自动抛出StopIteration异常</span></span><br></pre></td></tr></table></figure>

<p>生成器除了实现简洁外, 它还有节省内存的优点, 它不是一次性构建整个结果列表, 它有延迟计<br>算的特点, 按需产生结果</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-hello-world" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2020/03/26/hello-world/"
    >Hello World</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2020/03/26/hello-world/" class="article-date">
  <time datetime="2020-03-26T02:00:08.204Z" itemprop="datePublished">2020-03-26</time>
</a>
      
      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      

    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-select-poll-epoll-初探" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2018/05/11/select-poll-epoll-%E5%88%9D%E6%8E%A2/"
    >select poll epoll 初探</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2018/05/11/select-poll-epoll-%E5%88%9D%E6%8E%A2/" class="article-date">
  <time datetime="2018-05-11T03:11:11.000Z" itemprop="datePublished">2018-05-11</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="select-poll-epoll-初探"><a href="#select-poll-epoll-初探" class="headerlink" title="select poll epoll 初探"></a>select poll epoll 初探</h1><p>这三个都是所谓的synchronous I/O multiplexing（同步I/O多路复用），在学习这个之前，有必要了解一下常见的I/O模型，<br>而在了解I/O模型前又有必要了解一下内核空间及用户空间。</p>
<h2 id="1-内核空间-用户空间"><a href="#1-内核空间-用户空间" class="headerlink" title="1 内核空间/用户空间"></a>1 内核空间/用户空间</h2><p>所谓的内核空间就是操作系统使用的内存空间，用户空间就是用户进程使用的内存空间，为了操作系统的安全，用户进程不能直接<br>操作操作系统内存空间，所以，内核空间和用户空间的数据交换需要通过内核提供的一组接口进行，也就是常说的系统调用。</p>
<h2 id="2-I-O模型"><a href="#2-I-O模型" class="headerlink" title="2 I/O模型"></a>2 I/O模型</h2><p>I/O模型就是I/O操作的方式，I/O操作就是用户进程与外界数据交换的操作，而与外界进行数据交换需要操作系统内核提供支持，<br>常见的I/O模型有四种，阻塞I/O、非阻塞I/O、多路复用I/O、信号驱动I/O、异步I/O。</p>
<h3 id="2-1-阻塞I-O（blocking-I-O）"><a href="#2-1-阻塞I-O（blocking-I-O）" class="headerlink" title="2.1 阻塞I/O（blocking I/O）"></a>2.1 阻塞I/O（blocking I/O）</h3><p>阻塞I/O就是进程请求I/O操作时会阻塞，具体一点就是用户进程向操作系统发起I/O请求，例如read操作中调用了系统函数recvfrom，<br>内核收到请求后就开始了I/O操作的第一个阶段————准备数据，如果是网络I/O请求，那么内核需要等待足够的数据到来，这时数据<br>保存在内核缓冲区，在这这个等待过程中，用户进程一直处于阻止塞状态（当然用户的I/O请求中也可以设置非阻塞，下面会提到），<br>当数据准备好了，内核就会将数据从内核缓冲区中拷贝到用户空间。用户感知到的就是调用recvfrom后，进程阻塞，直到数据准备<br>好了返回给用户进程。这就是最易理解的I/O模式。</p>
<h3 id="2-2-非阻塞I-O（nonblocking-I-O）"><a href="#2-2-非阻塞I-O（nonblocking-I-O）" class="headerlink" title="2.2 非阻塞I/O（nonblocking I/O）"></a>2.2 非阻塞I/O（nonblocking I/O）</h3><p>可以设置socket使之成为non-blocking，继续以读操作为例子，在非阻塞I/O模式中，当用户进程调用recvfrom时，内核立即返回，<br>在内核还未准备好数据时返回error，用户进程可以隔一段时间再次调用recvfrom，直到内核准备好数据，就会把数据考哦被到用户<br>空间，完成I/O操作。</p>
<h3 id="2-3-I-O多路复用"><a href="#2-3-I-O多路复用" class="headerlink" title="2.3 I/O多路复用"></a>2.3 I/O多路复用</h3><p>I/O多路复用类似非阻塞I/O，不一样的是使用多路复用机制可以使一个进程同时处理多个网络连接的I/O，基本原理是通过select<br>poll epoll会不断轮询多个socket，当其中某个I/O就绪就会通知用户进程。</p>
<h3 id="2-3-异步I-O（Asynchronous-I-O）"><a href="#2-3-异步I-O（Asynchronous-I-O）" class="headerlink" title="2.3 异步I/O（Asynchronous I/O）"></a>2.3 异步I/O（Asynchronous I/O）</h3><p>异步I/O是一种完全不会阻塞的I/O模型，之所以说完全不会阻塞是因为使用这种方式发起I/O请求后，内核立即返回，之后内核准备<br>数据，数据准备好后直接拷贝至用户空间，最后向用户进程发送一个signal，告诉进程I/O操作完成。而非阻塞I/O模型中，非阻塞<br>的是内核数据准备阶段，在数据拷贝阶段还是会阻塞用户进程。</p>
<h3 id="2-4-信号驱动I-O（Signal-drived-I-O）"><a href="#2-4-信号驱动I-O（Signal-drived-I-O）" class="headerlink" title="2.4 信号驱动I/O（Signal drived I/O）"></a>2.4 信号驱动I/O（Signal drived I/O）</h3><p>使用信号驱动I/O时，当网络套接字可读后，内核通过发送SIGIO信号通知应用进程，于是应用可以开始读取数据。有时也称此方式为<br>异步I/O。但是严格讲，该方式并不能算真正的异步I/O，因为实际读取数据到应用进程缓存的工作仍然是由应用自己负责的，即需要<br>用户主动调用系统函数去读取数据。</p>
<h2 id="3-I-O多路复用之select-poll-epoll"><a href="#3-I-O多路复用之select-poll-epoll" class="headerlink" title="3 I/O多路复用之select poll epoll"></a>3 I/O多路复用之select poll epoll</h2><p>select poll epoll都属于I/O多路复用模式的实现。</p>
<h3 id="3-1-select"><a href="#3-1-select" class="headerlink" title="3.1 select"></a>3.1 select</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param n: readfds writefds exceptfds中的fd数量不能超过n+1</span></span><br><span class="line"><span class="comment"> * @param readfds: 需要监控的读操作fd</span></span><br><span class="line"><span class="comment"> * @param writefds: 需要监控的写操作fd</span></span><br><span class="line"><span class="comment"> * @param exceptfds: 需要监控的异常fd</span></span><br><span class="line"><span class="comment"> * @param timeout: 指定select可以等待的时间间隔，如果设成0秒和0毫秒，则select不等待，立即测试fd集中的所有fd，</span></span><br><span class="line"><span class="comment"> *                 如果设成NULL，等待无限久，可以被信号中断</span></span><br><span class="line"><span class="comment"> * @return 成功:返回三个集合中所有被设置的bit位数量|超时:返回0|失败:返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>fd_set是以位图的形式来存储这些文件描述符，n为位图的长度。<br>select优点：<br>目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点<br>select缺点：<br>1.每次调用 select()，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大，同时每次调用 select() 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大。<br>2.单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低   </p>
<h3 id="3-2-poll"><a href="#3-2-poll" class="headerlink" title="3.2 poll"></a>3.2 poll</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * @param fds: 需要监控的文吉安描述符及需要监控的事件</span></span><br><span class="line"><span class="comment"> * @param nfds: fds中的文件描述符总数</span></span><br><span class="line"><span class="comment"> * @param timeout: 和select一样但是两个字段单位分别是秒和微秒</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @return 成功:返回正整数，返回又时间发生的fd数量|超时:返回0（也表示无事件发生）|失败:返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd *fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>   fd;         <span class="comment">/* file descriptor */</span></span><br><span class="line">    short events;     <span class="comment">/* requested events */</span></span><br><span class="line">    short revents;    <span class="comment">/* returned events */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>poll使用链表保存文件描述符，因此没有了监视文件数量的限制。</p>
<h3 id="3-3-epoll"><a href="#3-3-epoll" class="headerlink" title="3.3 epoll"></a>3.3 epoll</h3><p>epoll实现机制和select/poll完全不一样，设想一下如下场景：有100万个客户端同时与一个服务器进程保持着TCP连接。而每一时刻，通常只有几百上千个TCP连接是活跃的(事实上大部分场景都是这种情况)。如何实现这样的高并发？<br>在select/poll时代，服务器进程每次都把这100万个连接告诉操作系统(从用户态复制句柄数据结构到内核态)，让操作系统内核去查询这些套接字上是否有事件发生，轮询完后，再将句柄数据复制到用户态，让服务器应用程序轮询处理已发生的网络事件，这一过程资源消耗较大，因此，select/poll一般只能处理几千的并发连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> <span class="built_in">size</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event *events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>
<p>epoll的用法一句话描述就是三步曲：<br>第一步：epoll_create()系统调用。此调用返回一个句柄，之后所有的使用都依靠这个句柄来标识。<br>第二步：epoll_ctl()系统调用。通过此调用向epoll对象中添加、删除、修改感兴趣的事件，返回0标识成功，返回-1表示失败。<br>第三部：epoll_wait()系统调用。通过此调用收集收集在epoll监控中已经发生的事件。    </p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag">操作系统</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-原码-反码-补码" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/12/19/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/"
    >原码、反码、补码学习</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/12/19/%E5%8E%9F%E7%A0%81-%E5%8F%8D%E7%A0%81-%E8%A1%A5%E7%A0%81/" class="article-date">
  <time datetime="2017-12-19T08:57:11.000Z" itemprop="datePublished">2017-12-19</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="原码、反码、补码学习"><a href="#原码、反码、补码学习" class="headerlink" title="原码、反码、补码学习"></a>原码、反码、补码学习</h1><p>思考：</p>
<blockquote>
<p>计算机中数的表示是怎样的？<br>计算机是如何做运算？  </p>
</blockquote>
<h2 id="计算机是二进制世界"><a href="#计算机是二进制世界" class="headerlink" title="计算机是二进制世界"></a>计算机是二进制世界</h2><p>众所周知，计算机世界里只有0和1，那么计算机中的数只能用二进制来表示，<br>举几个二进制数字例子：    </p>
<blockquote>
<p><em>括号中为二进制，其余为十进制</em><br>(0000 0001) = 1<br>(1111 1111) = 257   </p>
</blockquote>
<p>如何表示一个负数呢？很自然就能想到，使用一位用来表示符号，一般二进制数的第一位来表示符号，<br>0表示正数，1表示负数，例子：   </p>
<blockquote>
<p>(0000 0001) =&gt; 1<br>(1000 0001) =&gt; -1   </p>
</blockquote>
<p>这种表示方式就是所谓的<strong>原码</strong>，它很简单，容易被人脑所理解。不过使用它进行运算时，对计算机并不太友好，</p>
<h2 id="计算机数的运算"><a href="#计算机数的运算" class="headerlink" title="计算机数的运算"></a>计算机数的运算</h2><p>计算机是使用逻辑电路进行运算，下图就是简单的加法器：<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Full-adder_logic_diagram.svg/400px-Full-adder_logic_diagram.svg.png" alt="1-bit full adder"><br>图 一位简单全加器   </p>
<p>这个加法器有三个输入两个输出，一个加法器可以完成两位的加法运算，串联多个加法器可以做多位加法。<br>实现了加法器，但是如何做减法运算呢？难道还要实现一个减法器？答案是不需要，我们知道<code>a + b = a + (-b)</code>，<br>我们可以把减法转换成加法来计算，不过这个时候，使用原码就有问题了，不信我们试试看：      </p>
<blockquote>
<p>(84-81) = 84+(-81) = 3<br>  (0101 0100) 84的原码<br>  (1101 0001) -81的原码<br> ————————————<br> 1(0010 0101)          </p>
</blockquote>
<p>结果显然是错的，原码没办法使用加法器做加法运算，<strong>反码</strong>便出现了。   </p>
<h2 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h2><p>原码和反码可以互相转换，转换规则就是：  </p>
<blockquote>
<p>正数的反码和原码相同<br>负数的反码是原码除符号位外，其余位取反的结果  </p>
</blockquote>
<p>举个例子：      </p>
<blockquote>
<p>(15-125) = 15+(-125)<br>  (0000 1111) 15的原码   =&gt; (0000 1111) 15的反码<br>  (1111 1101) -125的原码 =&gt; (1000 0010) -125的反码<br>————————————————————<br>                            (1001 0001)   </p>
</blockquote>
<p>得出来的结果也是反码，转换成原码后是<code>(1110 1110)</code>，即为<code>-110</code>，结果正确！<br>不过，使用反码需要注意两点:  </p>
<blockquote>
<p>1.相加得到的结果也是反码，需要转换成原码<br>2.溢出一位后需要在最低位+1   </p>
</blockquote>
<p>使用补码，就没有问题了。</p>
<h2 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h2><p>正数的补码就是其本身，负数的补码就是其反码的最低位加1。   </p>
<blockquote>
<p>2-1 = 2+(-1) = 1<br>   (0000 0010) 2的原码   =&gt; (0000 0010) 2的反码   =&gt; (0000 0010) 补码<br>   (1000 0001) -1的原码  =&gt; (1111 1110) -1的反码  =&gt; (1111 1111) 补码<br>————————————————————————————————<br>  (0000 0001)    </p>
</blockquote>
<h2 id="隐藏其中的数学原理"><a href="#隐藏其中的数学原理" class="headerlink" title="隐藏其中的数学原理"></a>隐藏其中的数学原理</h2><p>todo</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-IP地址结构及子网划分" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/11/23/IP%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/"
    >IP地址结构及子网划分</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/11/23/IP%E5%9C%B0%E5%9D%80%E7%BB%93%E6%9E%84%E5%8F%8A%E5%AD%90%E7%BD%91%E5%88%92%E5%88%86/" class="article-date">
  <time datetime="2017-11-23T14:57:11.000Z" itemprop="datePublished">2017-11-23</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>todo</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BD%91%E7%BB%9C/" rel="tag">网络</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-散列" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/08/24/%E6%95%A3%E5%88%97/"
    >散列</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/08/24/%E6%95%A3%E5%88%97/" class="article-date">
  <time datetime="2017-08-24T14:32:11.000Z" itemprop="datePublished">2017-08-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <p>参考《数据结构与算法分析（C语言描述）》 第二版 第五章 散列</p>
<h1 id="什么是散列表？"><a href="#什么是散列表？" class="headerlink" title="什么是散列表？"></a>什么是散列表？</h1><p>散列表是一种数据结构，它支持对一组元素进行各种操作，不过它只支持二叉查找树所允许的一部分操作。<br>散列表的实现叫做散列，散列是一种可以用常数时间执行插入、删除和查找的技术，但是它对排序操作是不支持的。</p>
<h1 id="理想的散列表"><a href="#理想的散列表" class="headerlink" title="理想的散列表"></a>理想的散列表</h1><p>理想的散列表就是一个包含关键字的，具有固定大小的数组。每个关键字被映射到从 0 到 tableSize-1 这个范围中的某个数，<br>这个映射叫做散列函数，理想的情况下，任何两个不同的的关键字，映射到不同的单元。我们需要找一个散列函数，使能够在单元<br>间均匀的分配关键字。</p>
<h1 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h1><p>如果关键字是整数，那么直接返回 key % tableSize</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> tableSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> key % tableSize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而当关键字的取值具有一些不理想的性质时，上面这个散列函数就是一个不好的选择，例如，当tableSize = 10时，关键字都是<br>个位数为 0 的整数，那么上面这个散列函数返回的值永远是0，也就是说，所有的关键字都被映射到单元0了，这是不好的。为了使<br>分配的更均匀，tableSize最好为素数。<br>一般，关键字的的值都是字符串，那么有以下几种方法来实现散列函数</p>
<ul>
<li>第一种，把字符的ASCII码值加起来，然后再模tableSize。这样的缺点就是当tableSize很大时，分配就不会均匀。</li>
<li>第二种，假设关键字是由三个英文字母组成，那么三个字符有17576种组合（26的三次方），如果表大小是10007，<br>这就是一个合理的均匀分配，但是，英文并不是随机组合，三个字幕组成有效的单词大概只有2851个，即使没有冲突，<br>也只有表的28%被散列到，所以也是不合适的。</li>
<li>第三种涉及到字符串中所有字符，所以当关键字特别长时，计算会花费过多时间，解决方法就是不计算所有字符，而挑选其中的字符，<br>比如只计算奇数位上的字符。</li>
</ul>
<h1 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h1><p>当两个关键字计算后得出的散列值相同时，就会产生冲突，解决冲突有两种方法：分离链接法 &amp; 开放定址法</p>
<h2 id="分离链接法"><a href="#分离链接法" class="headerlink" title="分离链接法"></a>分离链接法</h2><p>该方法将所有散列值相同的元素保留到一个表中，这种方法的缺点就是使用了指针，由于给新单元分配指针需要时间，因此导致算法速度<br>较慢，另外，它还依赖另一种数据结构（链表）。</p>
<h2 id="开放定址法"><a href="#开放定址法" class="headerlink" title="开放定址法"></a>开放定址法</h2><p>开放定址法中如果遇到了冲突，则尝试选择另外的单元，直到找到空的单元为止。</p>
<h2 id="再散列"><a href="#再散列" class="headerlink" title="再散列"></a>再散列</h2><p>使用前面两种方法解决冲突时，当表的元素过多时，操作的运行时间将过长，而且insert操作可能失败。解决方案就是扩展表，使表增大<br>一倍，并使用一个新的散列函数，扫描原表中的元素，重新计算散列值并插入到新表中，这个操作就叫再散列。</p>
<h2 id="可扩散列"><a href="#可扩散列" class="headerlink" title="可扩散列"></a>可扩散列</h2><p>fuck，看不懂！</p>
<h1 id="散列表的应用"><a href="#散列表的应用" class="headerlink" title="散列表的应用"></a>散列表的应用</h1><ul>
<li>编译器中使用散列表跟踪源代码声明的变量，这种数据结构叫做<code>符号表</code>。</li>
<li>使用散列表解决图论问题。</li>
<li>游戏编程中</li>
<li>在线拼写检测程序</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>散列表以常数时间实现insert和find操作，但是当表中元素过多时，表的性能将下降。另外，当关键字的类型以及性质比较特殊时，选择<br>合适的散列散列函数也会很大程度上影响表的性能。</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-PEP-333——Python-Web服务器网关接口" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/08/24/PEP-333%E2%80%94%E2%80%94Python-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3/"
    >PEP333——Python Web服务器网关接口</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/08/24/PEP-333%E2%80%94%E2%80%94Python-Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2017-08-24T14:32:11.000Z" itemprop="datePublished">2017-08-24</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="PEP-333——Python-Web服务器网关接口-v1-0"><a href="#PEP-333——Python-Web服务器网关接口-v1-0" class="headerlink" title="PEP 333——Python Web服务器网关接口 v1.0"></a>PEP 333——Python Web服务器网关接口 v1.0</h1><p>Original: <a href="https://www.python.org/dev/peps/pep-0333/#abstract" target="_blank" rel="noopener">PEP 333——Python Web Server Gateway Interface v1.0</a>  </p>
<blockquote>
<p>PEP:    333<br>Title:    Python Web Server Gateway Interface v1.0<br>Author:    Phillip J. Eby <pje at telecommunity.com><br>Discussions-To:    Python Web-SIG <web-sig at python.org><br>Status:    Final<br>Type:    Informational<br>Created:    07-Dec-2003<br>Post-History:    07-Dec-2003, 08-Aug-2004, 20-Aug-2004, 27-Aug-2004, 27-Sep-2010<br>Superseded-By:    3333  </p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>注意：此份规范的更新版本支持python3.x、包含社区勘误表、附录表，以及说明，如果这是你想要的，那么去看<a href="https://www.python.org/dev/peps/pep-3333" target="_blank" rel="noopener">PEP 3333</a>。</p>
<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>这篇文档介绍了在服务器和python web应用程序（或框架）之间建立一套标准接口，使python web应用程序可以在多种web服务器之间运行，提高可移植性。</p>
<h2 id="原理及目标"><a href="#原理及目标" class="headerlink" title="原理及目标"></a>原理及目标</h2><p>目前python拥有大量web应用框架，<br>例如Zope，Quixote，Webware，SkunkWeb，PSO，以及Twisted Web，<br>等等<a href="http://www.python.org/cgi-bin/moinmoin/WebProgramming" target="_blank" rel="noopener">1</a>，<br>数量众多的选择对新手来说是个头疼的问题，<br>因为，他们对web框架的选择将会限制所能使用的web服务器，反之亦然。  </p>
<p>相比之下，尽管java也有大量web应用框架，<br>但是java servlet API使得任何使用java框架写的应用程序都可以在任何支持java sevlet的web服务器上运行。</p>
<p>python也需要那样一套可用的广泛传播的API，<br>无论服务器是用python语言写的（Medusa），<br>或者把python封装进去（mod_python），<br>或者通过网关协议调用python解释器来执行程序（CGI,FastCGI,etc）都将使得对框架的选择脱离web服务器的限制，<br>让用户自由选择最适合他们的组合，<br>而且还能使框架和web服务器的开发者们专注于做好他们擅长的工作。</p>
<p>因此，这份PEP提议在web服务器和web应用程序或框架之间建立一套简单而通用的接口：<br>Python Web服务器网关接口（WSGI）。</p>
<p>但是仅仅起草一份WSGI规范并不能解决python web服务器和框架现有的状况，<br>服务器、框架作者和维护人员必须真正的实现WSGI才会有效果。</p>
<p>然而，由于还没有任何服务器或者框架支持WSGI，<br>最初实现对WSGI的支持对作者来说并没有立即产生效果。<br>因此，WSGI规范必须简洁，<br>至少能使作者实现接口的成本比较低。</p>
<p>因此，服务器和框架两端的接口实现起来都比较简单，这对WSGI接口的实用性都非常重要，<br>对任何设计决策来说都是基本原则。</p>
<p>注意，然而，框架实现对WSGI的支持并不像使用WSGI接口那般简单。<br>WSGI提供一个完全没有多余功能的接口给框架作者，<br>因为多余的类似响应对象和cookie的处理将会阻碍框架中已实现的相同功能。<br>再一次，WSGI的目标是使服务器和应用或框架之间交互更简单，而不是创造一个新的框架。</p>
<p>还要注意的是，这个目标阻止WSGI需要任何已部署python版本中不存在的东西。<br>因此，这份规范并不提议或者要求使用新标准库，<br>另外WSGI不需要任何高于python2.2.2版本的特性。<br>（对未来python版本中，最好是在标准库提供的web服务器中实现对接口的支持。）</p>
<p>另外，对现存以及未来的框架和服务器实现起来都应该简单，<br>它还要能够简单创建请求预处理器和响应后处理器（？），<br>其他基于WSGI的“中间件”对他们的服务器来说像一个应用，<br>对他们的应用来说却像一个服务器。</p>
<p>如果中间件能够既简单又强健，<br>而且WSGI被服务器和框架广泛支持，<br>那么它将允许一个全新的python web应用框架：<br>一个由低耦合WSGI中间件组件组成的框架。<br>甚至框架作者可能选择重构他们框架中的服务以提供上述架构，<br>使用WSGI更像使用一个库，<br>而不是一个庞大的框架。<br>这将使得应用开发者能够选择最佳组件以应对特殊的应用场景，<br>而不是不得不接受同一个框架中不好的一面。</p>
<p>当然，要实现上述愿景，<br>还有一条很长的路要走。<br>在此期间，有足够的短期目标使WSGI能够在任何框架和服务器上使用。</p>
<p>最后，需要提到的是，目前的WSGI版本并没有规定任何特殊的结构来使用web服务器或网关部署一个应用。<br>目前，这是由服务器或网关定义的。<br>当足够多的服务器和框架实现了WSGI，可以提供多种不同的部署需求，<br>那么需要创建另一份PEP，为WSGI服务器和应用框架描述一个部署标准。</p>
<h2 id="规范概览"><a href="#规范概览" class="headerlink" title="规范概览"></a>规范概览</h2><p>WSGI接口有两端：服务器或网关端，应用或框架端。<br>应用端提供一个可调用对象给服务器端调用。<br>如何提供这个可调用对象的细节则由服务器或网关决定。<br>假设一些服务器或网关会要求应用提供一个部署脚本，用来提供给服务器或网关创建一个实例，<br>来提供一个应用程序对象。<br>其他的服务器或网关可能使用配置文件或者其他结构来指定从哪里引入（或者说获得）应用程序对象。</p>
<p>另外为了使通信双方更加纯粹，<br>可以使用中间件来同时实现WSGI的两端。<br>那么他对服务器来说是一个应用，<br>对应用过来说则是扮演服务器的角色，<br>还能用来提供扩展APIs，内容转换，导航，以及其他有用的功能。</p>
<p>贯穿这篇规范说明，<br>我们会使用“可调用对象”来表示一个“函数”，“方法”，“类”或者一个有<strong>call</strong>方法的实例。<br>至于这个“可调用搞对象”具体是什么，这取决于服务器，网关，或者应用根据需要选择合适的技术来实现可调用对象。</p>
<h3 id="应用端-框架端"><a href="#应用端-框架端" class="headerlink" title="应用端/框架端"></a>应用端/框架端</h3><p>应用对象就是一个简单的接受两个参数的可调用对象，<br>术语“对象”并不是特指一个真正的对象实例：<br>一个函数，方法，类或者实现了<strong>call</strong>方法的实例都可以作为一个应用对象。<br>应用对象必须要能够调用多次，<br>几乎所有的服务器或网关（除了CGI）都会有重复的请求。</p>
<blockquote>
<p>（注意：<br>虽然我们称它为应用对象，<br>但是应用开发者不应该把WSGI当作一个web programming API！<br>应用开发者们还是应该继续使用现有的，高级框架服务来开发他们的应用。<br>WSGI是框架和服务器开发者们的工具，而且不打算直接支持应用开发者。）</p>
</blockquote>
<p>这里有两个应用对象的例子；一个是函数，另一个是类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">simple_app</span><span class="params">(environ, start_response)</span>:</span></span><br><span class="line">    <span class="string">"""最简单的应用对象"""</span></span><br><span class="line">    status = <span class="string">'200 OK'</span></span><br><span class="line">    response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">    start_response(status, response_headers)</span><br><span class="line">    <span class="keyword">return</span> [<span class="string">'Hello world!\n'</span>]</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AppClass</span>:</span></span><br><span class="line">    <span class="string">"""实现和上面例子同样功能的应用对象，但是使用类来实现</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    （注意：‘AppClass’是一个应用，通过调用它返回一个‘AppClass’的实例，</span></span><br><span class="line"><span class="string">    一个通过可迭代返回值的应用对象。）</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    如果我们想使用‘AppClass’的实例作为应用对象，那就应该实现__call__</span></span><br><span class="line"><span class="string">    方法，那样就能用过调用实例来执行应用，而且需要创建一个实例供服务器</span></span><br><span class="line"><span class="string">    或网关使用。</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line">        self.environ = environ</span><br><span class="line">        self.start = start_response</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        status = <span class="string">'200 OK'</span></span><br><span class="line">        response_headers = [(<span class="string">'Content-type'</span>, <span class="string">'text/plain'</span>)]</span><br><span class="line">        self.start(status, response_headers)</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">"Hello world!\n"</span></span><br></pre></td></tr></table></figure>

<h3 id="服务器端-网关端"><a href="#服务器端-网关端" class="headerlink" title="服务器端/网关端"></a>服务器端/网关端</h3><p>HTTP客户端每次发送一个请求，服务器或网关都会调用应用对象一次，<br>为了好理解，这里有一个简单的CGI网关，<br>通过一个接受应用对象的函数实现。<br>注意这个简单的例子只能处理有限的错误状况，<br>因为一个未捕捉的异常默认将会通过sys.stderr输出，并且由服务器记录日志。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os, sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_with_cgi</span><span class="params">(application)</span>:</span></span><br><span class="line"></span><br><span class="line">    environ = dict(os.environ.items())</span><br><span class="line">    environ[<span class="string">'wsgi.input'</span>]        = sys.stdin</span><br><span class="line">    environ[<span class="string">'wsgi.errors'</span>]       = sys.stderr</span><br><span class="line">    environ[<span class="string">'wsgi.version'</span>]      = (<span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">    environ[<span class="string">'wsgi.multithread'</span>]  = <span class="literal">False</span></span><br><span class="line">    environ[<span class="string">'wsgi.multiprocess'</span>] = <span class="literal">True</span></span><br><span class="line">    environ[<span class="string">'wsgi.run_once'</span>]     = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> environ.get(<span class="string">'HTTPS'</span>, <span class="string">'off'</span>) <span class="keyword">in</span> (<span class="string">'on'</span>, <span class="string">'1'</span>):</span><br><span class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'https'</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        environ[<span class="string">'wsgi.url_scheme'</span>] = <span class="string">'http'</span></span><br><span class="line"></span><br><span class="line">    headers_set = []</span><br><span class="line">    headers_sent = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(data)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_set:</span><br><span class="line">             <span class="keyword">raise</span> AssertionError(<span class="string">"write() before start_response()"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">             <span class="comment"># Before the first output, send the stored headers</span></span><br><span class="line">             status, response_headers = headers_sent[:] = headers_set</span><br><span class="line">             sys.stdout.write(<span class="string">'Status: %s\r\n'</span> % status)</span><br><span class="line">             <span class="keyword">for</span> header <span class="keyword">in</span> response_headers:</span><br><span class="line">                 sys.stdout.write(<span class="string">'%s: %s\r\n'</span> % header)</span><br><span class="line">             sys.stdout.write(<span class="string">'\r\n'</span>)</span><br><span class="line"></span><br><span class="line">        sys.stdout.write(data)</span><br><span class="line">        sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">start_response</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> exc_info:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                <span class="keyword">if</span> headers_sent:</span><br><span class="line">                    <span class="comment"># Re-raise original exception if headers sent</span></span><br><span class="line">                    <span class="keyword">raise</span> exc_info[<span class="number">0</span>], exc_info[<span class="number">1</span>], exc_info[<span class="number">2</span>]</span><br><span class="line">            <span class="keyword">finally</span>:</span><br><span class="line">                exc_info = <span class="literal">None</span>     <span class="comment"># avoid dangling circular ref</span></span><br><span class="line">        <span class="keyword">elif</span> headers_set:</span><br><span class="line">            <span class="keyword">raise</span> AssertionError(<span class="string">"Headers already set!"</span>)</span><br><span class="line"></span><br><span class="line">        headers_set[:] = [status, response_headers]</span><br><span class="line">        <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">    result = application(environ, start_response)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">for</span> data <span class="keyword">in</span> result:</span><br><span class="line">            <span class="keyword">if</span> data:    <span class="comment"># don't send headers until body appears</span></span><br><span class="line">                write(data)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> headers_sent:</span><br><span class="line">            write(<span class="string">''</span>)   <span class="comment"># send headers now if body was empty</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            result.close()</span><br></pre></td></tr></table></figure>

<h3 id="中间件：同时扮演两端角色的组件"><a href="#中间件：同时扮演两端角色的组件" class="headerlink" title="中间件：同时扮演两端角色的组件"></a>中间件：同时扮演两端角色的组件</h3><p>“中间件”面对应用的时候扮演服务器的角色，而面对服务器的时候扮演应用的角色，<br>它提供以下功能：</p>
<ul>
<li>在相应的重写环境之后，根据目标URL把请求路由到不同的应用对象。</li>
<li>允许多个应用或者框架并行的运行在同一个进程中。</li>
<li>通过转发请求以及网络响应来实现负载平衡和远程处理。</li>
<li>执行内容预处理，例如应用XSL样式表。</li>
</ul>
<p>总之，中间件的存在是使“服务器/网关”端和“应用/框架”端之间透明，不需要任何特殊支持使两端能够交互。<br>想把中间件合并到应用的用户只需提供中间件组件给服务器，<br>中间件就好像是一个应用，配置好中间件使之去调用应用，<br>中间件又好像是一个服务器，代替服务器去调用应用。<br>当然，中间件封装的“应用”可能是另一个中间件封装的另一个应用，<br>如此循环，创建了所谓的“中间件堆栈”。</p>
<p>在极大程度上，中间件必须符合WSGI规范服务端和应用端的限制和要求。<br>在某些例子，对中间件的约束比单纯对服务器或应用还要严格，<br>这些要点将在规范中注明。</p>
<p>下面是一个中间件例子（非正式），它的作用是把文本转换成pig Latin式的儿童黑话（…?），<br>代码保存在Joe Strout的piglatin.py文件中。<br>（注意：一个健壮的中间件可能会使用更粗鲁的方式检查内容类型，<br>以及内容的编码格式。<br>另外，这个例子忽略了一个单词可能跨越块边界。）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> piglatin <span class="keyword">import</span> piglatin</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LatinIter</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"""Transform iterated output to piglatin, if it's okay to do so</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Note that the "okayness" can change until the application yields</span></span><br><span class="line"><span class="string">    its first non-empty string, so 'transform_ok' has to be a mutable</span></span><br><span class="line"><span class="string">    truth value.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, result, transform_ok)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> hasattr(result, <span class="string">'close'</span>):</span><br><span class="line">            self.close = result.close</span><br><span class="line">        self._next = iter(result).next</span><br><span class="line">        self.transform_ok = transform_ok</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.transform_ok:</span><br><span class="line">            <span class="keyword">return</span> piglatin(self._next())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> self._next()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Latinator</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># by default, don't transform output</span></span><br><span class="line">    transform = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, application)</span>:</span></span><br><span class="line">        self.application = application</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, environ, start_response)</span>:</span></span><br><span class="line"></span><br><span class="line">        transform_ok = []</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">start_latin</span><span class="params">(status, response_headers, exc_info=None)</span>:</span></span><br><span class="line"></span><br><span class="line">            <span class="comment"># Reset ok flag, in case this is a repeat call</span></span><br><span class="line">            <span class="keyword">del</span> transform_ok[:]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers:</span><br><span class="line">                <span class="keyword">if</span> name.lower() == <span class="string">'content-type'</span> <span class="keyword">and</span> value == <span class="string">'text/plain'</span>:</span><br><span class="line">                    transform_ok.append(<span class="literal">True</span>)</span><br><span class="line">                    <span class="comment"># Strip content-length if present, else it'll be wrong</span></span><br><span class="line">                    response_headers = [(name, value)</span><br><span class="line">                        <span class="keyword">for</span> name, value <span class="keyword">in</span> response_headers</span><br><span class="line">                            <span class="keyword">if</span> name.lower() != <span class="string">'content-length'</span></span><br><span class="line">                    ]</span><br><span class="line">                    <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">            write = start_response(status, response_headers, exc_info)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> transform_ok:</span><br><span class="line">                <span class="function"><span class="keyword">def</span> <span class="title">write_latin</span><span class="params">(data)</span>:</span></span><br><span class="line">                    write(piglatin(data))</span><br><span class="line">                <span class="keyword">return</span> write_latin</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> write</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> LatinIter(self.application(environ, start_latin), transform_ok)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Run foo_app under a Latinator's control, using the example CGI gateway</span></span><br><span class="line"><span class="keyword">from</span> foo_app <span class="keyword">import</span> foo_app</span><br><span class="line">run_with_cgi(Latinator(foo_app))</span><br></pre></td></tr></table></figure>


<h2 id="规范详述"><a href="#规范详述" class="headerlink" title="规范详述"></a>规范详述</h2><p>一个应用对象必须接受两个位置参数。<br>为了好理解，<br>我们分别给这两个参数取名为environ和start_response，<br>但是这也不是必须的。<br>服务器或网关必须用这两个位置参数去调用一个应用（例如，通过调用<code>result = application(environ, start_response)</code>）</p>
<p>environ参数是一个字典对象，<br>包含类似CGI环境参数。<br>这个对象必须是一个python内置的字典对象（不是一个子类，自定义字典类或者其他模拟字典类），<br>而且应用能够随意修改字典的内容。<br>字典还必须包含必要的WSGI变量（下节将会介绍），<br>以及包含服务器端扩展变量，将根据下面描述的来命名。</p>
<p>start_response参数是一个可调用对象，它接受两个必选参数和一个可选参数。<br>为了更好的理解，<br>我们分别命名这些参数status，response_headers，和exc_info，<br>但是他们同样不是必须叫这个名，<br>应用必须调用start_response对象，并且使用位置参数（例如，start_response(status, response_headers)）.</p>
<p>status参数是一个表状态的字符串，类似“999 Message here”，<br>response_headers是一个包含http响应头的元祖。<br>可选的exc_info参数在下节start_reponse()可调用对象和错误处理中介绍。<br>它仅在当应用程序出错或者打算在浏览器上显示错误信息的时候使用。</p>
<p><code>start_response()</code>必须返回一个<code>write</code>（主体数据）可调用对象，它接受一个位置参数：<br>HTTP响应主体的一部分字符串。<br>（注意：<code>write()</code>可调用对象仅用于某些现有框架必须的输出APIs；<br>如果可以避免，新的应用或框架就不应该适用这个对象。<br>参阅Buffering and Stream章节获取更多信息。）</p>
<p>当服务器调用时，<br>应用对象必须返回一个可迭代对象，返回0或更多字符串。<br>这可以通过很多方式来实现，<br>例如返回字符串列表<br>或者通过一个生成器函数实现应用程序对象，<br>或者用一个可迭代类实例来实现应用程序对象。<br>无论它时怎么实现的，<br>应用程序对象必须返回一个可迭代对象，返回0或更多字符串。</p>
<p>服务器或网关必须以非缓存的方式返回生成的字符串到客户机，<br>在另一个请求前，完成每一个字符串的返回。<br>（换句话说，应用必须自己做好缓存,<br>参阅Buffering and Stream章节获取更多有关应用程序输出处理的信息。）</p>
<p>服务器或网关按二进制字节序列来处理来处理生成的字符串：<br>尤其是，它应该确保行尾结束符不能被修改。<br>应用对象响应的数据必须必须适合在客户端展现。<br>（服务器或网关可能应用HTTP传输编码。或者其他实现HTTP功能的传输方式，例如字节范围传输。参阅下面的Other HTTP Features章节获取更多信息。）</p>
<p>如果能够调用<code>len(iterable)</code>，<br>服务器必须能够信任结果的准确度。<br>如果可迭代对象是通过应用提供的<code>__len__()</code>方法返回的，<br>则必须返回一个准确的结果。<br>（参阅Handling the Content-Length Header章节获取更多信息。）</p>
<p>如果应用返回的可迭代对象有一个<code>close()</code>方法，<br>服务器或网关必须调用那个方法以完成当前请求，<br>无论请求是否已经正常完成，或者由于错误提前终止<br>（这是用来支持应用程序的资源发布）。<br>这个协议是补充PEP 325的生成器支持章节，<br>以及其他常见有<code>close()</code>方法的可迭代对象。</p>
<p>（注意：应用必须在可迭代开始生成主题字符串之前调用<code>start_response()</code>，使得服务器能够在主体内容之前发送headers。）<br>然而，这个调用可以通过可迭代对象的首次迭代来调用实现，<br>所以，服务器必须不假设应用首先调用<code>start_response()</code>，然后在开始迭代。）</p>
<p>最后，服务器和网关必须不直接使用应用返回的可迭代对象的其他属性。<br>除非它在服务器或网关中是一个特别的实例，有自有的特别属性，<br>例如wsgi.file_wrapper返回“file wrapper”<br>（参阅Optional Platform-Specific File Handling）。<br>通常情况下，只有这里指定的属性，<br>或者通过例如PEP 234中的迭代APIs。</p>
<h3 id="变量environ"><a href="#变量environ" class="headerlink" title="变量environ"></a>变量<code>environ</code></h3><p>environ字典需要包含CGI环境变量，<br>定义在Common Gateway Interface规范<a href="http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt" target="_blank" rel="noopener">2</a>中。<br>下面的变量必须提供，<br>除非他们的值是空字符串，<br>则可能可以省略，除了额外注明的变量。</p>
<blockquote>
<ul>
<li><p>REQUEST_METHOD<br>The HTTP request method, such as “GET” or “POST”. This cannot ever be an empty string, and so is always required.  </p>
</li>
<li><p>SCRIPT_NAME<br>The initial portion of the request URL’s “path” that corresponds to the application object, so that the application knows its virtual “location”. This may be an empty string, if the application corresponds to the “root” of the server.  </p>
</li>
<li><p>PATH_INFO<br>The remainder of the request URL’s “path”, designating the virtual “location” of the request’s target within the application. This may be an empty string, if the request URL targets the application root and does not have a trailing slash.  </p>
</li>
<li><p>QUERY_STRING<br>The portion of the request URL that follows the “?”, if any. May be empty or absent.  </p>
</li>
<li><p>CONTENT_TYPE<br>The contents of any Content-Type fields in the HTTP request. May be empty or absent.  </p>
</li>
<li><p>CONTENT_LENGTH<br>The contents of any Content-Length fields in the HTTP request. May be empty or absent.  </p>
</li>
<li><p>SERVER_NAME, SERVER_PORT<br>When combined with SCRIPT_NAME and PATH_INFO, these variables can be used to complete the URL. Note, however, that HTTP_HOST, if present, should be used in preference to SERVER_NAME for reconstructing the request URL. See the URL Reconstruction section below for more detail. SERVER_NAME and SERVER_PORT can never be empty strings, and so are always required.  </p>
</li>
<li><p>SERVER_PROTOCOL<br>The version of the protocol the client used to send the request. Typically this will be something like “HTTP/1.0” or “HTTP/1.1” and may be used by the application to determine how to treat any HTTP request headers. (This variable should probably be called REQUEST_PROTOCOL, since it denotes the protocol used in the request, and is not necessarily the protocol that will be used in the server’s response. However, for compatibility with CGI we have to keep the existing name.)  </p>
</li>
<li><p>HTTP_ Variables<br>Variables corresponding to the client-supplied HTTP request headers (i.e., variables whose names begin with “HTTP_”). The presence or absence of these variables should correspond with the presence or absence of the appropriate HTTP header in the request.  </p>
</li>
</ul>
</blockquote>
<p>A server or gateway should attempt to provide as many other CGI variables as are applicable. In addition, if SSL is in use, the server or gateway should also provide as many of the Apache SSL environment variables [5] as are applicable, such as HTTPS=on and SSL_PROTOCOL. Note, however, that an application that uses any CGI variables other than the ones listed above are necessarily non-portable to web servers that do not support the relevant extensions. (For example, web servers that do not publish files will not be able to provide a meaningful DOCUMENT_ROOT or PATH_TRANSLATED.)</p>
<p>A WSGI-compliant server or gateway should document what variables it provides, along with their definitions as appropriate. Applications should check for the presence of any variables they require, and have a fallback plan in the event such a variable is absent.</p>
<p>Note: missing variables (such as REMOTE_USER when no authentication has occurred) should be left out of the environ dictionary. Also note that CGI-defined variables must be strings, if they are present at all. It is a violation of this specification for a CGI variable’s value to be of any type other than str.</p>
<p>In addition to the CGI-defined variables, the environ dictionary may also contain arbitrary operating-system “environment variables”, and must contain the following WSGI-defined variables:</p>
<table>
<thead>
<tr>
<th>Variable</th>
<th>Value</th>
</tr>
</thead>
<tbody><tr>
<td>wsgi.version</td>
<td>The tuple (1, 0), representing WSGI version 1.0.</td>
</tr>
<tr>
<td>wsgi.url_scheme</td>
<td>A string representing the “scheme” portion of the URL at which the application is being invoked. Normally, this will have the value “http” or “https”, as appropriate.</td>
</tr>
<tr>
<td>wsgi.input</td>
<td>An input stream (file-like object) from which the HTTP request body can be read. (The server or gateway may perform reads on-demand as requested by the application, or it may pre- read the client’s request body and buffer it in-memory or on disk, or use any other technique for providing such an input stream, according to its preference.)</td>
</tr>
<tr>
<td>wsgi.errors</td>
<td>An output stream (file-like object) to which error output can be written, for the purpose of recording program or other errors in a standardized and possibly centralized location. This should be a “text mode” stream; i.e., applications should use “\n” as a line ending, and assume that it will be converted to the correct line ending by the server/gateway.    <br><br>    For many servers, wsgi.errors will be the server’s main error log. Alternatively, this may be sys.stderr, or a log file of some sort. The server’s documentation should include an explanation of how to configure this or where to find the recorded output. A server or gateway may supply different error streams to different applications, if this is desired.</td>
</tr>
<tr>
<td>wsgi.multithread</td>
<td>This value should evaluate true if the application object may be simultaneously invoked by another thread in the same process, and should evaluate false otherwise.</td>
</tr>
<tr>
<td>wsgi.multiprocess</td>
<td>This value should evaluate true if an equivalent application object may be simultaneously invoked by another process, and should evaluate false otherwise.</td>
</tr>
<tr>
<td>wsgi.run_once</td>
<td>This value should evaluate true if the server or gateway expects (but does not guarantee!) that the application will only be invoked this one time during the life of its containing process. Normally, this will only be true for a gateway based on CGI (or something similar).</td>
</tr>
</tbody></table>
<p>Finally, the environ dictionary may also contain server-defined variables. These variables should be named using only lower-case letters, numbers, dots, and underscores, and should be prefixed with a name that is unique to the defining server or gateway. For example, mod_python might define variables with names like mod_python.some_variable.</p>
<h3 id="Input-and-Error-Streams"><a href="#Input-and-Error-Streams" class="headerlink" title="Input and Error Streams"></a>Input and Error Streams</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>[1] The Python Wiki “Web Programming” topic (<a href="http://www.python.org/cgi-bin/moinmoin/WebProgramming" target="_blank" rel="noopener">http://www.python.org/cgi-bin/moinmoin/WebProgramming</a>)<br>[2] The Common Gateway Interface Specification, v 1.1, 3rd Draft (<a href="http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt" target="_blank" rel="noopener">http://ken.coar.org/cgi/draft-coar-cgi-v11-03.txt</a>)</p>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/PEP/" rel="tag">PEP</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
    <article id="post-python多线程编程" class="article article-type-post" itemscope
  itemprop="blogPost" data-scroll-reveal>

  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2017/08/05/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"
    >python多线程编程</a> 
</h2>
 

    </header>
    

    
    <div class="article-meta">
      <a href="/2017/08/05/python%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/" class="article-date">
  <time datetime="2017-08-05T03:11:11.000Z" itemprop="datePublished">2017-08-05</time>
</a>
      
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a>
  </div>

      
    </div>
    

    

    
    <div class="article-entry" itemprop="articleBody">
      
      

      
      <h1 id="python多线程编程"><a href="#python多线程编程" class="headerlink" title="python多线程编程"></a>python多线程编程</h1><ol>
<li>为啥使用多线程？</li>
</ol>
<ul>
<li>有时候计算机要处理的任务之间没有因果关系，都是独立的，也就是说任务的结果不会影响其他任务，我们就会希望计算机并行的处理多个任务，这就要使用多线程。当然还有其他方式来实现多任务并行处理，比如说串行程序使用一个或多个计时器来实现一个多路复用的方案，一个串行程序需要从每个I/O终端通道来检查用户的输入，然而程序在读取I/O时不能阻塞，因为用户的输入是不确定时间的，阻塞会影响其他I/O通道的处理，串行程序必须使用非阻塞I/O或拥有计时器的阻塞I/O。由于串行程序只有一个执行线程，为了防止执行其中某一个任务占用太多时间，并对用户的响应进行合理分配，实现起来会有非常复杂的控制流，难以维护。</li>
</ul>
<ol start="2">
<li>进程和线程到底是啥？</li>
</ol>
<ul>
<li>进程（重量级进程）是一个执行中的程序，每个进程都有自己的地址空间、内存、数据栈、以及其他一些用于跟踪执行的辅助数据，操作系统管理其上所有进程的执行，为这些进程分配时间。进程可以通过派生（fork或spawn）新的进程来执行其他任务，由于每个进程都有自己的地址空间和内存。所以进程间只能通过进程间通信的方式共享信息。线程（轻量级进程）与进程类似，但是它们是在一个进程空间下面执行的，并共享上下文，可以将它们认为是在一个主进程中并行运行的一些迷你进程。</li>
</ul>
<ol start="3">
<li>python和线程和全局解释器锁</li>
</ol>
<ul>
<li>python代码是由python虚拟机执行的，python虚拟机其实就是模拟cpu核心，所以，同一时刻只能由一个线程在执行，多线程执行实质上是虚拟机不停的切换执行中的线程，为了保证同一时刻只有一个线程在执行，这里就用到全局解释器锁，所以对虚拟机的访问是由全局解释器锁来控制的。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. 设置GIL（Global Interpreter Lock）</span><br><span class="line">2. 切换一个线程去执行</span><br><span class="line">3. 执行</span><br><span class="line">    a. 指定数量的字节码指令</span><br><span class="line">    b. 线程主动让出控制权</span><br><span class="line">4. 切换出线程</span><br><span class="line">5. 解锁GIL</span><br><span class="line">6. 重复上述步骤</span><br></pre></td></tr></table></figure>
当调用外部代码（例如C/C++拓展内置函数），GIL会保持锁定，因为这期间没有python字节码计数，但是可以靠在拓展代码中手动解锁GIL。</li>
</ul>

      
      <!-- reward -->
      
    </div>
    
    
      <!-- copyright -->
      
    <footer class="article-footer">
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/python/" rel="tag">python</a></li></ul>


    </footer>

  </div>

  

  

  

</article>
    
  </article>
  

  
  <nav class="page-nav">
    
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul class="list-inline">
      <li>
        &copy;
        2020
        Ouyang Ziyi
      </li>
      <li>
        
        Powered by
        
        
        <a href="https://hexo.io" target="_blank">Hexo</a> Theme <a href="https://github.com/Shen-Yu/hexo-theme-ayer" target="_blank">Ayer</a>
        
      </li>
    </ul>
    <ul class="list-inline">
      <li>
        
        
        <span>
  <i>PV:<span id="busuanzi_value_page_pv"></span></i>
  <i>UV:<span id="busuanzi_value_site_uv"></span></i>
</span>
        
      </li>
      
      <li>
        <!-- cnzz统计 -->
        
      </li>
    </ul>
  </div>
</footer>
      <div class="float_btns">
        <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

      </div>
    </main>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/avatar.jpg" alt="oyzy"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">Home</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">Archives</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">Categories</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <script>
      if (window.matchMedia("(max-width: 768px)").matches) {
        document.querySelector('.content').classList.remove('on');
        document.querySelector('.sidebar').classList.remove('on');
      }
    </script>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/alipay.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/wechat.jpg">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-2.0.3.min.js"></script>


<script src="/js/lazyload.min.js"></script>


<script>
  try {
    var typed = new Typed("#subtitle", {
      strings: ['面朝大海，春暖花开', '愿你一生努力，一生被爱', '想要的都拥有，得不到的都释怀'],
      startDelay: 0,
      typeSpeed: 200,
      loop: true,
      backSpeed: 100,
      showCursor: true
    });
  } catch (err) {
  }

</script>





<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css">
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>



<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script>


<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
      tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      }
  });

  MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
      for(i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
      }
  });
</script>

<script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.6/unpacked/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script>
  var ayerConfig = {
    mathjax: true
  }
</script>



<script src="/js/busuanzi-2.3.pure.min.js"></script>



<script type="text/javascript" src="https://js.users.51.la/20544303.js"></script>

    
  </div>
</body>

</html>